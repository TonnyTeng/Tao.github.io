<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tao的博客</title>
  <icon>https://www.gravatar.com/avatar/0ec302a3316b44d288c6f37788db9f6e</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tao1010.github.io/"/>
  <updated>2018-07-02T12:22:04.137Z</updated>
  <id>http://tao1010.github.io/</id>
  
  <author>
    <name>Tao</name>
    <email>dengtao_dev@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS其他-CocoaPods-应用</title>
    <link href="http://tao1010.github.io/2018/07/02/iOS/iOS%E5%85%B6%E4%BB%96/iOS%E5%85%B6%E4%BB%96-CocoaPods-%E5%BA%94%E7%94%A8/"/>
    <id>http://tao1010.github.io/2018/07/02/iOS/iOS其他/iOS其他-CocoaPods-应用/</id>
    <published>2018-07-02T01:36:49.000Z</published>
    <updated>2018-07-02T12:22:04.137Z</updated>
    
    <content type="html"><![CDATA[<p>CocoaPods是ruby写的，用于管理Xcode开发时第三方开源的工具。</p><pre><code>Mac自带Ruby环境</code></pre><p>一、环境配置</p><a id="more"></a><p>1.Ruby软件源的处理</p><pre><code>查看Ruby版本：    ruby -v验证Ruby源：    gem source -l结果：    *** CURRENT SOURCES ***    https://ruby.taobao.org  #只要存在淘宝的源就可以安装    https://gems.ruby-china.org添加Ruby源:    gem sources -a https://ruby.taobao.org删除Ruby源:    gem sources --remove https://ruby.taobao.org #删除淘宝ruby软件源    gem sources --remove https://gems.ruby-china.org #删除China 社区ruby软件源更新Ruby:    sudo gem update --system</code></pre><p>2.安装CocoaPods到电脑</p><pre><code>方法一:推荐    sudo gem install -n /usr/local/bin cocoapods 方法二:可能报错    sudo gem install cocoapods 如果安装多个Xcode:    sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer</code></pre><p>3.下载配置到本地</p><pre><code>pod setup #设置仓库，把所有上传到cocoapods的第三方框架下载每个版本和网络地址以及一些其他描述信息到本地</code></pre><p>二、CocoaPods的使用<br><br>1.查找第三方</p><pre><code>pod search xxxeg:    pod search AFNetworking</code></pre><p>2.创建Podfile文件</p><pre><code>cd  xxx/xxx #切换到项目文件夹下方法一:    touch Podfile #新建文件Podfile方法二：    pod init #会自动配置 Podfile文件内容，编辑时只需添加第三方即可</code></pre><p>3.编辑Podfile文件</p><pre><code>方法一：    vim Podfile    #进入编辑界面    i               #开始编辑    键盘 ‘esc’      #退出编辑    ：wq               #写入完成保持并退出编辑界面方法二：    open Podfile    #会用文本编辑器打开</code></pre><p>4.Podfile文件内容</p><pre><code>写法1：        target &apos;MyApp&apos; do   #针对MyApp项目导入依赖库           pod &apos;xxx&apos;,&apos;~&gt;1.0&apos;   end 写法2:     # 下面两行是指明依赖库的来源地址    source &apos;https://github.com/CocoaPods/Specs.git&apos;    source &apos;https://github.com/Artsy/Specs.git&apos;    # 说明平台是ios，版本是9.0    platform :ios, &apos;9.0&apos;    # 忽略引入库的所有警告（强迫症者的福音啊）    inhibit_all_warnings!    # 针对MyApp target引入AFNetworking    # 针对MyAppTests target引入OCMock，    target &apos;MyApp&apos; do         pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;         target &apos;MyAppTests&apos; do           inherit! :search_paths            pod &apos;OCMock&apos;, &apos;~&gt; 2.0.1&apos;         end    end</code></pre><p>5.安装CocoaPods到项目</p><pre><code>pod install</code></pre><p>三、其他<br><br>1.Podfile中的依赖项</p><pre><code>pod 指定特定的依赖库podspec 可以提供一个API来创建podspecstarget 通过target指定依赖范围source 指定pod来源 默认使用CocoaPods官方Source，建议默认</code></pre><p>2.依赖库版本问题</p><pre><code>#指定依赖库具体版本格式：pod &apos;AFNetworking&apos;, &apos;3.0&apos; #不指定依赖库版本，默认选取最新版本:pod &apos;AFNetworking&apos;#指定版本范围pod &apos;AFNetworking&apos;, &apos;&gt; 3.0&apos; #高于3.0的任意一个版本pod &apos;AFNetworking&apos;, &apos;&lt;=3.0&apos; #低于(包含)3.0的任意一个版本pod &apos;AFNetworking&apos;, &apos;～&gt;3.1.2&apos; #版本3.1.2 到 版本3.2(不包含)之间的任意一个版本</code></pre><p>3.use_frameworks!</p><pre><code>use_frameworks使用的区别:    使用 use_frameworks! 命令会在Pods工程下生成Frameworks目录下生成依赖库的framework    不使用 use_frameworks! 命令会在Pods工程下的Products目录下生成.a 的静态库</code></pre><p>推荐使用 use_frameworks！纯OC项目一般不使用 swift必须使用 use_frameworks! </p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>静态库(静态链接库 .a)</td><td>在编译时会将库copy一份到目标程序中，编译完成之后，目标程序不依赖外部的库，也可以运行</td><td>会使应用程序变大</td></tr><tr><td>动态库(.dylib)</td><td>编译时只存储了指向动态库的引用;可以多个程序指向这个库，在运行时才加载，不会使体积变大</td><td>运行时加载会损耗部分性能，并且依赖外部的环境，如果库不存在或者版本不正确则无法运行</td></tr><tr><td>Framework</td><td>实际上是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发</td><td>暂无</td></tr></tbody></table><p>4.pod install 和 pod update区别</p><pre><code>pod install 下载并安装Pod    当podfile 文件中 有 “增、删、改 pod”的操作后使用；    pod install 执行完后将会下载依赖库的版本号添加到podfile.lock文件；    pod install 根据podfile.lock文件列出的已安装的pod版本信息，只负责下载安装podfile.lock中不存在的pod，不会自动更新已安装的pod版本；pod update 更新已存在Pod    按规则将podfile文件中的pod更新到最新版本，并将pod版本信息写入podfile.lock;        </code></pre><p>四、错误<br><br>1.While executing gem …</p><pre><code>复现:    执行命令 sudo gem install cocoapods 报错  处理:    sudo gem install -n /usr/local/bin cocoapods</code></pre><p>参考资料:<br><br>1.<a href="https://www.jianshu.com/p/8a0fd6150159" target="_blank" rel="noopener">Podfile配置</a><br><br>2.<a href="https://blog.csdn.net/cwf19860527/article/details/54139214" target="_blank" rel="noopener">pod install 和 pod update区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CocoaPods是ruby写的，用于管理Xcode开发时第三方开源的工具。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Mac自带Ruby环境
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一、环境配置&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tao1010.github.io/categories/iOS/"/>
    
    
      <category term="iOS其他" scheme="http://tao1010.github.io/tags/iOS%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Python-python基础-高级变量</title>
    <link href="http://tao1010.github.io/2018/06/29/Python/Python%E5%9F%BA%E7%A1%80/Python-python%E5%9F%BA%E7%A1%80-%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F/"/>
    <id>http://tao1010.github.io/2018/06/29/Python/Python基础/Python-python基础-高级变量/</id>
    <published>2018-06-29T07:19:03.000Z</published>
    <updated>2018-07-03T13:30:45.115Z</updated>
    
    <content type="html"><![CDATA[<p>非数字型 数据类型 的特点：</p><pre><code>都是一个序列，可以看成容器；取值 []遍历 for in计算长度、最大/最小值、比较、删除链接 + 和 重复 *切片</code></pre><p>一、列表 - List    </p><a id="more"></a><p>1.定义</p><pre><code>列表(List) 是Python中使用最频繁的数据类型，其他语言称为数组；专门用于存储一串信息,存储相同类型的数据；列表用 [] 定义，数据之间用 , 分隔；列表的 索引|下标  从 0 开始eg:    name_list = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;]</code></pre><p>2.列表常用方法<br><br><img src="list_method.png" alt="list_method">    </p><pre><code>xx.extend # 将列表A添加到列表B中时，A、B的数据类型必须一致del 列表名[下标] #关键字 del 本质上是用来将变量从内存中删除xx.remove[&apos;a&apos;] #删除一个存在的元素，如果有多个元素 a 则只删除第一次出现的aeg:    del name_list[1] #将name_list中下标为1的元素 “李四” 从内存中删除    name_list.count[&apos;a&apos;] #统计列表name_list中 ‘a’ 出现的次数 </code></pre><p>3.其他</p><pre><code>使用关键字 后不需要 ()    del name_list[1] #删除 name_list 列表下标为1的 数据 内存也删除使用函数、方法 都需要 ()        name_list.reverse() #反转    name_list.append[&apos;Jack&apos;] #在列表name_list 最后加上 ‘Jack’ 数据函数和方法的区别：    方法和函数一样都是封装的独立的功能；    方法需要通过对象来调用，表示针对这个 对象 要做的操作：        对象.方法名(参数)</code></pre><p>4.循环遍历</p><pre><code>在Python中，为提高列表的遍历效率 专门提供 迭代iteration 遍历for循环迭代遍历格式eg:    for name in name_list:        print(name)</code></pre><p>二、元祖 - Tuple<br><br>1.定义</p><pre><code>和列表类似，区别：    可以保存不同类型的数据；    元祖的元素不能修改；    定义方式为:元祖名()；eg:    tuple = (&apos;张三&apos;, 18, 1.75)    print(&quot;姓名:%s \t 年龄:%d \t 身高:%.2f&quot; % (tuple[0],tuple[1],tuple[2]))</code></pre><p>2.注意</p><pre><code>元祖定义一个元素时，后面也必须加 ,eg：info_tuple = (50,)解析： 若不加 , python解释器会认会 info_tuple = (50) 这是一个变量名</code></pre><p>3.常用方法</p><pre><code>eg:tuple = (&apos;张三&apos;, 18, 1.75)取数据: tuple[1]取索引: tuple.index(&quot;张三&quot;)统计计数:    tuple.count(&quot;张三&quot;)包含元素个数: len(tuple)</code></pre><p>4.循环遍历</p><pre><code>#使用格式字符串频接 元祖 tuple 不方便,因为元祖中保存的数据类型不同for item in tulpe:    print(item)</code></pre><p>5，应用场景</p><pre><code>函数的参数和返回值，一个函数可以接受多个参数，或者一次返回多个数据；格式字符串    后面的()本质上是一个元祖；列表不可以被修改，以保护数据安全；</code></pre><p>5.元祖和列表的转换</p><pre><code>元祖--&gt;列表list(tuple) #可修改tuple数据列表--&gt;元祖tulpe（list）eg：    info_tuple = (&apos;张三&apos;, 18, 1.75)    num_list = [1,2,3,4]    #列表转元祖    num_tulpe = tuple(num_list)    print(num_tulpe)    #元祖转列表    info_list = list(info_tuple)    print(info_list)</code></pre><p>三、字典 - dictionary<br><br>1.定义</p><pre><code>字典用 {} 定义,可用来定义多个数据；    通常用于存储描述一个 对象 的相关信息使用 键值对 存储数据，键值对间使用 , 分隔;键和值间用 : 分隔;键必须唯一的同时只能使用字符串、数字、或元祖，值可以是任何数据类型；eg:    xiaoming = {&quot;name&quot;:&quot;小明&quot;,                  &quot;age&quot; :18,                  &quot;gender&quot;: True,                          &quot;height&quot;: 1.75}</code></pre><p>2.和列表的区别：</p><pre><code>字典：是 无序 对象的集合列表: 是 有序 对象的集合</code></pre><p>3.字典的方法</p><pre><code>获取所有 key 列表: 字典.keys()获取所有 value 列表: 字典.values()获取所有 (key,value)元祖 列表: 字典.items()获取键值对数量: len(字典)查：xiaoming[&quot;name&quot;] #key错误或不存在 程序报错增：xiaoming[&quot;weight&quot;] = 75 #key不存在 新增改：xiaoming[&quot;age&quot;] = 20    #key存在 修改删：xiaoming.pop(&quot;gender&quot;) #删除 指定key 的键值对,若key错误或不存在，程序报错合并字典:字典1.update(字典2)    被合并的字典包含已经存在的键值对，会覆盖原有的键值对    eg:        temp_dict = {&quot;weight&quot;:75}        xiaoming.update(temp_dict)清空字典:清空所有键值对    xiaoming.clear()</code></pre><p>4.循环遍历</p><pre><code>#变量k是每一次循环中，获取到的键值对的keyfor k in xiaoming:    print(&quot;字典中的键值对为 key: %s, value:%s&quot; % (k,xiaoming[k]))</code></pre><p>5.应用场景</p><pre><code>使用对歌键值对 ，存储描述一个物体的相关信息 - 描述更复杂的数据信息；将 多个字典 放在一个 列表 中，进行遍历，在循环体内部针对每个字典进行 相同的处理；</code></pre><p>四、字符串<br><br>1.字符串的定义</p><pre><code>可以一对 “”,也可用一对 ‘’,推荐 “ ”</code></pre><p>2.常用方法</p><pre><code>获取长度: len(字符串1)统计小字符串2 在 大字符串2 中出现的次数: 字符串1.count(字符串2)获取指定位置的字符: 字符串1[index]获取指定字符在字符串的位置: 字符串1.index(字符串2)    若 字符串2 不存在 程序报错循环遍历:    for char in 字符串1:        print(char)</code></pre><p>3.方法分类<br><br><img src="str-is.png" alt="str-is"><br><img src="str-find.png" alt="str-find"></p><pre><code>判断类型 - 9    str.isspace() #判断是否只包含空白或空格字符查找和替换 - 7    str.startwith() #大小写有区别大小写转换 - 5文本对齐 - 3去除空白字符 - 3拆分和连接 - 5</code></pre><p>五、公共方法</p><p>六、高级变量</p><p>参考资料:<br><br>1.<a href="">黑马视频</a><br><br>2.<a href="https://www.w3cschool.cn/python/" target="_blank" rel="noopener">W3C-Python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非数字型 数据类型 的特点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;都是一个序列，可以看成容器；
取值 []
遍历 for in
计算长度、最大/最小值、比较、删除
链接 + 和 重复 *
切片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一、列表 - List    &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://tao1010.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python-python基础-函数</title>
    <link href="http://tao1010.github.io/2018/06/29/Python/Python%E5%9F%BA%E7%A1%80/Python-python%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/"/>
    <id>http://tao1010.github.io/2018/06/29/Python/Python基础/Python-python基础-函数/</id>
    <published>2018-06-29T05:16:07.000Z</published>
    <updated>2018-07-02T12:22:04.129Z</updated>
    
    <content type="html"><![CDATA[<p>一、函数的概念和作用</p><a id="more"></a><p>1.函数的概念</p><pre><code>把具有独立功能的代码块 组织成一个小的模块 在需要的时候调用</code></pre><p>2.函数的使用</p><pre><code>定义函数 -  封装 独立的功能调用函数</code></pre><p>3.函数的作用</p><pre><code>提高编码效率；解决代码重用；</code></pre><p>二、函数的使用<br><br>1.格式</p><pre><code>def 函数名():    函数封装的代码    ...解析:    def  define的缩写    函数名 见名知意，能表达函数的功能    函数名    名称规则：        字母、数字、下划线        不能一数字开头        不能和关键字重名</code></pre><p>2.使用步骤：<br><br>方法一：在不同文件定义、调用函数</p><pre><code>1.新建文件 hm_custom_function.py2.编写函数代码    #函数一： 九九表    def multiple_table():        print(&quot;==================九九乘法表==================&quot;)        row = 1        while row &lt;= 9:            col = 1            while col &lt;= row:                if col == row:                    print(&quot;%d * %d = %d&quot; % (col,row,(col * row)))                else:                    print(&quot;%d * %d = %d&quot; % (col, row, (col * row)),end=&quot;\t&quot;)                col += 1            row +=1        print(&quot;==================九九乘法表==================&quot;)    #函数二： say hello    def say_hello():        print(&quot;Hello Python&quot;)3.函数的使用    导入函数文件 - 在需要使用函数的文件中         import hm_custom_function    调用函数        hm_custom_function.multiple_table()        hm_custom_function.say_hello()</code></pre><p>方法二：在同一文件定义、调用函数</p><pre><code>必须 先定义 再调用 函数(Python的解释器必须要先知道函数的存在)#定义函数def say_hello():    &quot;&quot;&quot; 函数说明&quot;&quot;&quot;    print(&quot;Hello Python&quot;)#使用函数say_hello()</code></pre><p>3.函数的调试<br><br><img src="function.png" alt="function"></p><pre><code>单步进入 - step into单步越过 - step out</code></pre><p>4.函数文档说明</p><pre><code>在定义函数的下方输入：    &quot;&quot;&quot; 函数说明 &quot;&quot;&quot;eg:    def say_hello():        &quot;&quot;&quot; 函数说明&quot;&quot;&quot;        print(&quot;Hello Python!&quot;)</code></pre><p>三、函数的参数<br><br>1.函数参数的使用</p><pre><code>在函数名后的()内 写入参数多个参数之间 使用 , 分隔</code></pre><p>2.参数的作用</p><pre><code>增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据形参    定义函数时，小括号内的参数    函数内部，可做变量使用实参    调用函数时，传递的参数</code></pre><p>3.eg:</p><pre><code>#hm_cumstom_function.pydef sum_2_num(num1,num2): #定义函数       &quot;&quot;&quot;实现两个数字的求和&quot;&quot;&quot;    print(&quot;%d + %d = %d&quot; % (num1,num2,(num2 + num1)))#hm_04_函数.pyimport hm_custom_function #导入自定义函数hm_custom_function.sum_2_num(10,20)    #函数调用</code></pre><p>四、函数的返回值<br>1.返回值    </p><pre><code>函数完成执行后，给调用者的一个结果；使用 关键字return 可以返回结果；使用 return 后，后续代码不会再执行；使用 变量 接受 返回值；</code></pre><p>五、函数的嵌套</p><p>1.tips</p><pre><code>函数的调用可以在定义之前</code></pre><p>2.eg:</p><pre><code>def test1():    print(&quot;test1&quot;)    test2()def test2():    print(&quot;*&quot; * 20)</code></pre><p>六、模块<br><br>1.模块概念</p><pre><code>模块是Python程序架构的核心概念类似工具包，想要使用工具包中工具，必须 import 这个模块    可以使用函数 模块名.函数    可以使用变量 模块名.变量每个以扩展名 .py 结尾的python 源代码文件 都是一个模块在模块中定义的 全局变量、 函数 都是模块能够给外界直接使用的工具</code></pre><p>2.模块名</p><pre><code>是一个标志符；命名规则：    字母、数字、下划线    不能以数字开头    不能以下划线开头        </code></pre><p>3.其他</p><pre><code>pyc文件可提高程序的执行速度pyc - 是xx.py 文件通过编译后生成的二进制文件xx.pyc若修改了 xx.py文件 编译时会重新生成 xx.pyc二进制文件</code></pre><p>参考资料:<br><br>1.<a href="">黑马视频</a><br><br>2.<a href="https://www.w3cschool.cn/python/" target="_blank" rel="noopener">W3C-Python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、函数的概念和作用&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://tao1010.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS其他-脚本自动打包</title>
    <link href="http://tao1010.github.io/2018/06/29/iOS/iOS%E5%85%B6%E4%BB%96/iOS%E5%85%B6%E4%BB%96-Python%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"/>
    <id>http://tao1010.github.io/2018/06/29/iOS/iOS其他/iOS其他-Python脚本自动打包/</id>
    <published>2018-06-29T01:17:57.000Z</published>
    <updated>2018-07-02T12:22:04.138Z</updated>
    
    <content type="html"><![CDATA[<p>脚本打包的使用场景：</p><pre><code>主要用于测试分发，正式发布建议使用手动打包(对脚本没有掌握情况下)；企业账号和其他账号使用的不同的脚本文件；自动打包的大小和手动打包的大小有区别(打包效率和包的优化上有所取舍)；</code></pre><p>一、Python脚本打包<br></p><a id="more"></a><p>1.缺点</p><pre><code>配置内容较多目前只支持 .xcodeproj 的工程,    不支持 .xcworkspace 的工程</code></pre><p>二、jenkins 脚本打包</p><p>三、shell脚本打包</p><p>参考资料:<br><br>一、Python脚本打包<br><br>1.<a href="https://mp.weixin.qq.com/s/5f2Pd8RHBN7TClZDZlx_Gw" target="_blank" rel="noopener">Python脚本-iOS自动打包</a><br><br>2.<a href="https://www.jianshu.com/p/1f47066da6f7" target="_blank" rel="noopener">Python脚本-iOS自动打包2</a><br><br>3.<a href="https://github.com/hades0918/ipapy" target="_blank" rel="noopener">Python 打包脚本</a><br><br>4.<a href="https://github.com/FIRHQ/fir-cli/blob/master/README.md" target="_blank" rel="noopener">蒲公英Fir分发平台</a><br><br>5.<a href="https://www.jianshu.com/p/1f47066da6f7" target="_blank" rel="noopener">Python自动打包</a><br>二、jenkins 脚本打包<br><br>1.<a href="https://www.jianshu.com/p/6a3a009da35b" target="_blank" rel="noopener">Jenkins集成iOS全自动打包</a><br></p><p>三、shell脚本打包<br><br>1.<a href="http://zackzheng.info/2015/12/27/2015-12-27-an-automated-script-for-building-archiving-submission-sending-emails/" target="_blank" rel="noopener">详解Shell脚本实现iOS自动化编译打包提交</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;脚本打包的使用场景：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主要用于测试分发，正式发布建议使用手动打包(对脚本没有掌握情况下)；
企业账号和其他账号使用的不同的脚本文件；
自动打包的大小和手动打包的大小有区别(打包效率和包的优化上有所取舍)；
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一、Python脚本打包&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tao1010.github.io/categories/iOS/"/>
    
    
      <category term="iOS其他" scheme="http://tao1010.github.io/tags/iOS%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Python-python基础-逻辑</title>
    <link href="http://tao1010.github.io/2018/06/28/Python/Python%E5%9F%BA%E7%A1%80/Python-python%E5%9F%BA%E7%A1%80-%E9%80%BB%E8%BE%91/"/>
    <id>http://tao1010.github.io/2018/06/28/Python/Python基础/Python-python基础-逻辑/</id>
    <published>2018-06-28T06:47:22.000Z</published>
    <updated>2018-07-02T12:22:04.131Z</updated>
    
    <content type="html"><![CDATA[<p>程序流程</p><pre><code>顺序 - 从上而下，顺序执行分支 - 根据条件判断，决定执行代码的分支循环 - 让 特点代码重复 执行</code></pre><p>一、分支语句</p><a id="more"></a><p>1.if语句</p><pre><code>格式：if 判断条件:    #if顶格写 注意添加冒号:    dosomething... # 一个tab键或4个空格eg1:    price = float(input(&quot;请输入苹果单价(元/斤):&quot;))    if price &gt; 5:        print(&quot;苹果价格太贵了,吃不起&quot;)        ...eg2:    price = float(input(&quot;请输入苹果单价(元/斤):&quot;))    if price &gt; 5:        print(&quot;苹果价格太贵了,吃不起&quot;)        ...    else:        print(&quot;价格可以接受&quot;)        ...eg3:    if 条件1:        dosomething1    elif 条件2:        dosomething2    else:        dosomething3解析：    只有 if语句时  if语句和下方缩进的部分 看成一个代码块 -- eg1    if和else语句 以及下方缩进的部分 看成一个完整的代码块 -- eg2    if、elif、else以及各自缩进的部分，看成一个完成的代码块 -- eg3</code></pre><p>2.运算符</p><pre><code>在Python中使用运算符(其他相同，仅如下有区别):    ==     #等于不同类型不能进行比较；</code></pre><p>3.逻辑运算</p><pre><code>Python中逻辑运算符：     and #与     or  #或     not #非逻辑运算符可以把多个条件按照逻辑连接起来，变成更复杂逻辑eg:    # 实例4    age = int(input(&quot;请输入0-120之间的年龄:&quot;))    if (age &gt; 0) and (age &lt; 120):        print(&quot;年龄正确&quot;)    else:        print(&quot;年龄错误!&quot;)    # 实例5    python_score = 80    c_score = 90    if python_score &gt; 60 or c_score &gt; 60:        print(&quot;考试通过&quot;)    else:        print(&quot;重考&quot;)    # 实例6    is_employee = True    if not is_employee:        print(&quot;不允许入内&quot;)    else:        print(&quot;请进&quot;)</code></pre><p>4.if嵌套</p><pre><code># 实例7-火车站安检has_ticket = bool(input(&quot;请输入是否买票1 - 买票 | 0 - 未买票:&quot;))if has_ticket:    print(&quot;有车票,开始安检...&quot;)    knife_length = float(input(&quot;请输入携带道具长度:&quot;))    if knife_length &lt;= 20:        print(&quot;安检通过&quot;)    else:        print(&quot;携带管制刀具,长度:%.2f,安检未通过!&quot; % knife_length)else:    print(&quot;请买票!&quot;)</code></pre><p>5.实例：石头剪刀布</p><pre><code>使用随机数：1.导入工具包    import random #导入随机数模块的工具包2.使用随机函数(输入 模块名称 后面输入 . 键盘 tab 可查看所有模块函数)    random.randint(a,b) #返回[a,b]之间的整数，包含a和b# 实例7 - 石头剪刀布&quot;&quot;&quot;    1.控制台输入 石头 - 1 | 剪刀 - 2 | 布 - 3    2.电脑 随机 出拳    3.比较胜负&quot;&quot;&quot;import randomperson = int(input(&quot;请出拳(石头 - 1 | 剪刀 - 2 | 布 - 3):&quot;))# computer = 1 # 假设电脑先出石头computer = random.randint(1,3)computer_str = &quot;石头&quot;if computer == 2:    computer_str = &quot;剪刀&quot;if computer == 3:    computer_str = &quot;布&quot;if (computer == 1 and person == 3) \        or (computer == 2 and person == 1) \        or (computer == 3 and person == 2): # 电脑先出石头    print(&quot;您赢了&quot;)elif computer == person:    print(&quot;平局!&quot;)else:    print(&quot;您输了!&quot;)print(&quot;电脑出拳: %s&quot; % computer_str)</code></pre><p>二、循环语句<br><br>1.while 循环</p><pre><code>语法格式：    while 条件(判断 计数器 是否达到目标次数):        条件满足时，dosomething1        条件满足时，dosomething2        条件满足时，dosomething3        ...        处理条件(计数器 + 1)eg:打印5次 “Hello Pyhton”    count = 0    while count &lt; 5:        print(&quot;Hello Pyhton&quot;)        count = count + 1 # &lt;==&gt; count += 1注意可能存在死循环(未修改条件)</code></pre><p>2.赋值运算符</p><pre><code>+= # 加法赋值 a += c &lt;==&gt; a = a + c-= # 减法赋值 a -= c &lt;==&gt; a = a - c*= # 乘法赋值 a *= c &lt;==&gt; a = a * c/= # 除法赋值 a /= c &lt;==&gt; a = a / c//= # 取整除赋值 a //= c &lt;==&gt; a = a // c%= # 取模赋值  a %= c &lt;==&gt; a = a % c**= #幂赋值 a **= c &lt;==&gt; a = a ** c</code></pre><p>3.break和continue</p><pre><code>break - 退出循环，不再执行后续代码continue - 退出当次循环，    继续执行下一次循环    注意计数变量的变化，防止死循环</code></pre><p>4.循环嵌套</p><pre><code>如果不希望末尾增加换行，可以在 print 函数输出内容的后面加上 end=&quot;&quot;其中&quot;&quot;中间可以指定 print 函数输出内容之后继续显示的内容eg:    print(&quot;hello&quot;,end=&quot;&quot;)eg2:    # 实例3    &quot;&quot;&quot;    *    **    ***    ****    *****    &quot;&quot;&quot;    row = 1    while row &lt;= 5:        col = 1        while col &lt;= row:            if row == col:                print(&quot;*&quot;)            else:                print(&quot;*&quot; , end=&quot;&quot;)            col += 1        row += 1    eg3:九九表        # 实例4 - 九九表        &quot;&quot;&quot;        1*1=1        2*1=2   2*2=4        3*1=3   3*2=6   3*3=9        4*1=4   4*2=8   4*3=12  4*4=16        5*1=5   5*2=10  5*3=15  5*4=20  5*5=25        6*1=6   ...        7*1=7   ...        8*1=8   ...        9*1=9   ...        &quot;&quot;&quot;        row = 1        while row &lt;= 9:            col = 1            while col &lt;= row:                if col == row:                        print(&quot;%d * %d = %d&quot; % (col,row,(col * row)))                   &lt;!--                     print(&quot;%d&quot; % row, end=&quot;*&quot;)                    print(&quot;%d&quot; % col, end=&quot;=&quot;)                    print(&quot;%d&quot; % (row * col))                    --&gt;                else:                      print(&quot;%d * %d = %d&quot; % (col, row, (col * row)),end=&quot;    &quot;)                    &lt;!--                    print(&quot;%d&quot; % row , end=&quot;*&quot;)                    print(&quot;%d&quot; % col , end=&quot;=&quot;)                    print(&quot;%d&quot; % (row * col), end=&quot;  &quot;)                    --&gt;                col += 1            row +=1</code></pre><p>5.其他<br><br>多个字符串的输出</p><pre><code>eg:    row = 1    col = 2    print(&quot;%d * %d&quot; % (col, row))    print(&quot;%d * %d = %d&quot; % (col, row, (col * row)),end=&quot;    &quot;)</code></pre><p>转义字符 </p><pre><code>\t  横向制表符 协助输出文本子啊垂直方向保持对齐    print(&quot;%d * %d = %d&quot; % (col, row, (col * row)),end=&quot;\t&quot;)\n  换行符     print(&quot;hello \n Python&quot;)\&quot; 可以在控制台输出 “ \&apos; \r 回车</code></pre><p>参考资料:<br><br>1.<a href="">黑马视频</a><br><br>2.<a href="https://www.w3cschool.cn/python/" target="_blank" rel="noopener">W3C-Python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序流程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;顺序 - 从上而下，顺序执行
分支 - 根据条件判断，决定执行代码的分支
循环 - 让 特点代码重复 执行
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一、分支语句&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://tao1010.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS模块-UIButton</title>
    <link href="http://tao1010.github.io/2018/06/28/iOS/iOS%E6%A8%A1%E5%9D%97/iOS%E6%A8%A1%E5%9D%97-UIButton/"/>
    <id>http://tao1010.github.io/2018/06/28/iOS/iOS模块/iOS模块-UIButton/</id>
    <published>2018-06-28T01:27:59.000Z</published>
    <updated>2018-06-28T13:14:57.877Z</updated>
    
    <content type="html"><![CDATA[<p>一、UIButton简介<br><br><img src="button2.png" alt="button2"></p><a id="more"></a><p>二、UIButton的图文<br><br><img src="button.png" alt="button"></p><p>1.解析<br></p><pre><code>UIEdgeInsets insets = {top, left, bottom, right};正数就是距相应的边的距离增加，负数就是距相应的距离减少button.imageView.image尺寸：    button.currentImage.size.height    button.currentImage.size.widthbutton.titleLabel文本的尺寸：    button.titleLabel.intrinsicContentSize.height    button.titleLabel.intrinsicContentSize.width//1.图左文右 - 默认UIButton *button1 = [buttonArray objectAtIndex:0];[button1 setImageEdgeInsets:UIEdgeInsetsMake(0,0,0,0)];[button1 setTitleEdgeInsets:UIEdgeInsetsMake(0,0,0,0)];//2.图文居中UIButton *button2 = [buttonArray objectAtIndex:1];[button2 setImageEdgeInsets:UIEdgeInsetsMake(0,0,0,-button2.titleLabel.intrinsicContentSize.width)];[button2 setTitleEdgeInsets:UIEdgeInsetsMake(0,-button2.currentImage.size.width,0,0)];//3.图右文左UIButton *button3 = [buttonArray objectAtIndex:2];[button3 setImageEdgeInsets:UIEdgeInsetsMake(0,0,0,-button3.titleLabel.intrinsicContentSize.width * 2)];[button3 setTitleEdgeInsets:UIEdgeInsetsMake(0,-button3.currentImage.size.width * 2,0,0)];//4.图上文下UIButton *button4 = [buttonArray objectAtIndex:3];[button4 setImageEdgeInsets:UIEdgeInsetsMake(-button4.titleLabel.intrinsicContentSize.height,0,0,-button4.titleLabel.intrinsicContentSize.width)];[button4 setTitleEdgeInsets:UIEdgeInsetsMake(0,-button4.currentImage.size.width,-button4.currentImage.size.height,0)];//5.图文显示其一UIButton *button5 = [buttonArray objectAtIndex:4]; //6.图下 文上UIButton *button6 = [buttonArray objectAtIndex:5];[button6 setImageEdgeInsets:UIEdgeInsetsMake(0,0,-button6.titleLabel.intrinsicContentSize.height,-button6.titleLabel.intrinsicContentSize.width)];[button6 setTitleEdgeInsets:UIEdgeInsetsMake(-button6.currentImage.size.height,-button6.currentImage.size.width,0,0)]; </code></pre><p>三、UIButton点击事件<br><br><img src="responder.png" alt="iOS上的响应者链"><br><br>1.阐述从点击屏幕上的UIButton后，到UIButton收到点击事件的过程</p><pre><code>runloop和响应链需要说的清楚。UIResponder、UIControl、UIView的关系。响应者链(responder chain)：    当一个事件发生时，如果first responder不处理，事件就会继续往下传递，被下个responder接收，如果下个responder也不处理，又会被下下个rsponder接收...直到一个responder处理了事件或者没有responder。这些responder按照传递次序连接起来的链条就构成了响应者链。    UIApplication 是一个响应者链的终点，它的nextResponder指向nil，整个响应者链结束。</code></pre><p>参考资料:<br><br>1.<a href="https://www.zybuluo.com/MicroCai/note/66142" target="_blank" rel="noopener">iOS Events 和 Responder</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、UIButton简介&lt;br&gt;&lt;br&gt;&lt;img src=&quot;button2.png&quot; alt=&quot;button2&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tao1010.github.io/categories/iOS/"/>
    
    
      <category term="iOS模块" scheme="http://tao1010.github.io/tags/iOS%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Python-python基础-语法和变量</title>
    <link href="http://tao1010.github.io/2018/06/27/Python/Python%E5%9F%BA%E7%A1%80/Python-python%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95%E5%92%8C%E5%8F%98%E9%87%8F/"/>
    <id>http://tao1010.github.io/2018/06/27/Python/Python基础/Python-python基础-语法和变量/</id>
    <published>2018-06-27T08:40:25.000Z</published>
    <updated>2018-07-02T12:22:04.131Z</updated>
    
    <content type="html"><![CDATA[<p>一、算数运算符</p><a id="more"></a><pre><code>+ - * /  # 加减乘除//  # 取整除 eg 9 // 2 输出 4**  # 幂 eg： 次方、乘方 2 ** 3 = 8&quot;-&quot; * 20    #输出连续20个‘-’</code></pre><p>先乘除后加减<br><br>同级运算符 从左到右<br><br>二、程序执行原理<br><br>1.计算机核心硬件</p><pre><code>CPU    中央处理器，一块超大规模的集成电路    负责处理数据/计算内存    临时 存储数据 断点后数据消失    速度快    空间小 单价高硬盘    永久存储数据    速度慢    空间大 单价低</code></pre><p>2.程序执行原理</p><pre><code>程序 运行 之前 是保存在 硬盘 中当要运行一个程序时    操作系统会让 CPU 把程序复制到 内存 中    CPU 执行 内存 中的程序代码程序要执行，首先要被加载到 内存</code></pre><p>3.Python程序执行原理</p><pre><code>操作系统会让 CPU 把 Python解释器 程序复制到 内存 中Python解释器 根据语法规则， 从上而下 让 CPU 翻译 Python程序中的代码CPU 负责执行翻译完的程序代码确认解释器的位置which python查看python文件大小ls -lh /usr/bin/python查看具体文件大小ls -lh /usr/bin/python</code></pre><p>4.程序作用</p><pre><code>程序 用来 处理数据 的,变量 就是用来 存储数据 的</code></pre><p>三、变量<br><br>1.变量的定义</p><pre><code>每个变量在使用前必须赋值,变量赋值后才能被创建eg:    qq_number = &apos;x123456x&apos;    qq_password = &apos;123456&apos;    print(&apos;QQ号码: &apos; + qq_number)    print(&apos;QQ密码: &apos; + qq_password)可以用其他变量的运算值 定义一个变量eg:    price = 5.0    weight = 3    total = price * weight</code></pre><p>2.变量命名</p><pre><code>标志符就是变量名和函数名；    字母、数字、下划线；    不能以数字开头；    不能与关键字重名；关键字：Python内部已经使用的标志符；    import  #可以导入一个“工具包”    查看关键字：        import keyword #导入关键字工具包        print(keyword.kwlist)    # 输出关键字列表Python 中的标志符 是 区分大小写的变量名由多个单词组成时： - Python中推荐方法    每个单词都使用小写;    单词与单词间使用 下划线(_) 连接;    eg:first_name、last_name驼峰命名法：    小驼峰        firstName、lastName    大驼峰：        FirstName、LastName</code></pre><p>3.变量类型</p><pre><code>在Python中，定义变量时不需要指定变量类型在运行时，Python解释器，会根据赋值语句等号右侧的数据自动推导出变量中保存的数据的准确类型数字型    bool(True 或 False)    float    int # python2.x中整型包含int、long    complex(复数型 - 科学计算，平面场、波动、电感电容等)非数字型    字符串 - str、    列表、    元祖、    字典使用 type 函数 查看变量类型eg:    name = &quot;Jike&quot;  #str    age = 18          #int    gender = True  #bool    type(name)</code></pre><p>4.不同类型变量间的计算</p><pre><code>数值型变量可以直接计算    布尔型 参与数字运算 True - 1  | False - 0eg:    a = True    b = 10.5    c = b - a #  9.5    字符串变量间 用 + 拼接字符串eg:    firstName = &quot;dong&quot;    lastName = &quot;haha&quot;    name = firstName + lastName字符串变量 和 整数 用 * 拼接eg:    firstName = &quot;dong&quot;            name = firstName * 3 # 表示 将3个连续的firstName字符串 赋值给 name</code></pre><p>四、变量的输入输出<br><br>1.输入</p><pre><code>如果要获取用户在键盘上输入的信息，需要使用 input 函数；用户输入的任何内容python都认为是一个字符串；语法：变量 = input(&quot;提示信息&quot;)  eg:    input(&quot;请输入登录账号:&quot;)    name = input(&quot;请输入登录账号:&quot;) # 用变量 name 接收 键盘输入的内容</code></pre><p>2.变量类型转换</p><pre><code>int(x)         #将 x 转换为一个 整数float(x)     #将 x 转换为一个 浮点数str(x)         #将 x 转换为一个 字符串eg:    type(int(&quot;123&quot;))        #将字符串123 --&gt; 整数123</code></pre><p>3.eg:</p><pre><code>price = input(&quot;请输入 apple 单价 （元/斤）：&quot;)weight = input(&quot;请输入 apple 重量 (斤):&quot;)money = float(price) * float(weight)print(&quot;顾客支付金额 (元): &quot; + str(money))等价于price = float(input(&quot;请输入 apple 单价 （元/斤）: &quot;))weight = float(input(&quot;请输入 apple 重量 (斤): &quot;))print(&quot;顾客支付金额 (元): &quot; + str(price * weight))</code></pre><p>4.格式化输出</p><pre><code>%s #字符串%d #有符号十进制整数 %06d 表示输出的整数显示位数，不足的地方使用0补齐%f #输出 浮点数 %.02f表示小数点后显示2位%% #输出%格式：    print(&quot;格式化字符串&quot; % 变量1)    print(&quot;格式化字符串&quot; % (变量1,变量2,变量3...))eg:    print(&quot;顾客支付金额 (元): %s &quot; % str(price * weight))        print(&quot;顾客支付金额 (元): %.2f &quot; % (price * weight))    print(&quot;顾客支付金额 (元): %06d &quot; % int(price * weight))</code></pre><p>参考资料:<br><br>1.<a href="">黑马视频</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、算数运算符&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://tao1010.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>iOS模式-简介</title>
    <link href="http://tao1010.github.io/2018/06/27/iOS/iOS%E6%A8%A1%E5%BC%8F/iOS%E6%A8%A1%E5%BC%8F-%E7%AE%80%E4%BB%8B/"/>
    <id>http://tao1010.github.io/2018/06/27/iOS/iOS模式/iOS模式-简介/</id>
    <published>2018-06-27T05:35:20.000Z</published>
    <updated>2018-07-02T12:22:04.139Z</updated>
    
    <content type="html"><![CDATA[<p>一、设计模式、架构模式、框架</p><a id="more"></a><p>1.设计模式</p><pre><code>对某种环境中反复出现的问题以及解决该问题的方案的描述规范；增加代码可重用性，简洁可靠；eg：代理模式、迭代器模式、策略模式等；</code></pre><p>2.架构模式</p><pre><code>为管理复杂的应用程序而出现的一种模式；eg: MVC架构、MVVM架构；</code></pre><p>3.框架</p><pre><code>通常是代码的重用；为已经解决问题的具体实现方法，能直接执行或复用；一个框架中往往包含一种或多种设计模式；eg：Foundation、UIKit、AFNetworking、MJRefresh等；</code></pre><p>4.区别</p><pre><code>设计模式 比 框架 更抽象；设计模式 比 框架 更小的元素；</code></pre><p>二、设计模式<br><br>1.分类:<br></p><pre><code>创建型    ...    单例模式 - 避免一个全局使用的类频繁的创建和销毁；    工厂模式 - 解决接口选择的问题，创建过程延迟到子类进行；    ...结构型    ...    代理模式 - 为其它对象提供一种代理以控制对这个对象的访问；    ...行为型    ...    观察者模式 - 解决一个对象改变状态给其它对象通知的问题；    策略模式 - 定义一系列算法，把他们封装起来，并且使他们可以相互替换；</code></pre><p><img src="mode.png" alt="mode"><br><br>三、观察者模式<br><br>1.解决问题</p><pre><code>解决了一个对象改变状态给其它对象通知的问题；</code></pre><p>2.解决方案</p><pre><code>经典观察者模式    当 A 对 B 的变化感兴趣，需要监听 B 的状态变化，就注册为 B 的观察者，当 B 发生变化时通知 A，告诉 A 此时 B 发生了变化，A 根据 B 的变化做相应的操作响应；eg: KVO、Delegate、NSNotificationCenter等</code></pre><p>2.具体实现<br>eg1:KVO举例</p><pre><code>注册观察者//观察属性name[_myName addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew || NSKeyValueChangeOldKey context:nil];//观察属性myView[self addObserver:self forKeyPath:@&quot;myView&quot; options:NSKeyValueObservingOptionNew || NSKeyValueChangeOldKey context:nil];响应操作//一旦属性被操作了，这里会自动响应（上面设置观察的属性才会在这响应）- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context {    if ([keyPath isEqualToString:@&quot;name&quot;]) {        ...    }     if ([keyPath isEqualToString:@&quot;myView&quot;]) {        ...    }}移除观察者- (void)dealloc {    [_myName removeObserver:self forKeyPath:@&quot;name&quot;];    [self removeObserver:self forKeyPath:@&quot;myView&quot;];}</code></pre><p>eg2:NSNotificationCenter</p><pre><code>注册观察者[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didRotate:) name:@&quot;registerKVO&quot; object:nil];响应操作//解析消息内容- (void)didRotate:(UIInterfaceOrientation)fromInterfaceOrientation{   ...}移除观察者[[NSNotificationCenter defaultCenter] removeObserver:self];</code></pre><p>四、单例模式<br><br>1.解决问题</p><pre><code>避免一个全局使用的类频繁的创建和销毁；</code></pre><p>2.解决方案：</p><pre><code>eg1：GCD - 线程安全创建一个全局单例+ (Singleton *)sharedInstance{    static id instance = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        instance = [[self alloc] init];    });    return instance;}eg2:单例宏定义创建一个 A 类A.h    #undef    AS_SINGLETON    #define AS_SINGLETON( __class ) \    + (__class *)sharedInstance;    #undef    DEF_SINGLETON    #define DEF_SINGLETON( __class ) \    + (__class *)sharedInstance{ \    static dispatch_once_t once; \    static __class * __singleton__; \    dispatch_once( &amp;once, ^{ \    __singleton__ = [[__class alloc] init]; \    } ); \    return __singleton__; \    }创建单例类 BB.h    @interface B : NSObject    ...    AS_SINGLETON(B)    ...    @endB.m    @implementation B    ...    DEF_SINGLETON(B)    ...    @end</code></pre><p>五、Delegate模式<br><br>1.解决问题</p><pre><code>为其它对象提供一种代理以控制对这个对象的访问；</code></pre><p>2.解决方案</p><pre><code>创建一个类：NetworkFetcherNetworkFetcher.h    @protocol NetworkFetcherDelegate &lt;NSObject&gt;    @required    - (void)printHello;    @optional    - (void)didReceiveData:(NSData *)data;    - (void)didFailWithError:(NSError *)error;    - (void)didUpdateProgressTo:(CGFloat)progress;    @end    @interface GRHNetworkFetcher : NSObject    @property (nonatomic, assign)id&lt;NetworkFetcherDelegate&gt; delegate;    @endNetworkFetcher.m    //不实现协议方法创建一个使用协议方法的类：AA.m    - (void)doSometing {        if ([self.delegate respondsToSelector:@selector(didReceiveData:)]) {            [self.delegate didReceiveData:nil];        }    }    解析：        respondsToSelector: 来判断委托对象是否实现了相关方法。如果实现了，就调用；如果没有实现，就不执行任何操作；</code></pre><p>参考资料:<br><br>1.<a href="https://www.jianshu.com/p/afe8e0c6362f" target="_blank" rel="noopener">设计模式</a><br><br>2.<a href="https://www.jianshu.com/p/dd84eaaff115" target="_blank" rel="noopener">iOS Delegate模式性能优化</a><br><br>3.<a href="https://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="noopener">最全设计模式导学目录</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、设计模式、架构模式、框架&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tao1010.github.io/categories/iOS/"/>
    
    
      <category term="模式" scheme="http://tao1010.github.io/tags/%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS第三方库-FMDB</title>
    <link href="http://tao1010.github.io/2018/06/26/iOS/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-FMDB/"/>
    <id>http://tao1010.github.io/2018/06/26/iOS/iOS第三方库/iOS第三方库-FMDB/</id>
    <published>2018-06-26T05:23:13.000Z</published>
    <updated>2018-06-26T15:42:29.394Z</updated>
    
    <content type="html"><![CDATA[<p>一、FMDB基本信息<br></p><a id="more"></a><p>1.版本信息</p><pre><code>pod &apos;FMDB&apos;, &apos;~&gt; 2.7&apos;</code></pre><p>2.结构<br><br><img src="fmdb.png" alt="fmdb"><br></p><pre><code>FMDatabase    一个 FMDatabase 对象代表一个单独的SQLite数据库(不是表)，用来执行SQL语句(增、删、改、查);FMDatabaseAdditions    扩展 FMDatabase 类 新增对查询结果至返回单个值的方法进行简化,对表、列是否存在、版本号，校验SQL等功能；        FMResultSet    使用 FMDatabase 执行查询后的结果集；FMDatabaseQueue    用于多线程中执行多个查询或更新，使用串行队列，线程安全的；FMDatabasePool    使用任务池，对多线程提供支持，优先选择FMDatabaseQueue；</code></pre><p>3.简介</p><pre><code>FMDB是iOS中对 libsqlite3.tbd 库 的封装；    更加面向对象；    非常轻量、灵活；    线程安全；    存在跨平台的局限性；</code></pre><p>二、libsqlite3 和 FMDB<br></p><pre><code>libsqlite3是iOS中纯C语言操作Sqlite数据库的一个库文件;</code></pre><p>1.SQLite3 操作数据库需要使用3个步骤：</p><pre><code>1.使用sqlite3_open()函数打开数据库;2.使用sqlite3_exec()函数执行非查询的SQL语句:    创建数据库；    创建数据表；    增、删、改、查等操作；3.使用SQLite_close()函数释放资源;</code></pre><p>2.基本使用对比<br><br>数据库操作对象</p><pre><code>C语言方式：    sqlite3 *db;FMDB方式：    FMDatabase *db;</code></pre><p>打开数据库</p><pre><code>//1.获取数据库文件路径NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];NSString *fileName = [doc stringByAppendingPathComponent:@&quot;students.sqlite&quot;];C语言方式：    -(void)openDB{        //2.将OC字符串转换为c语言的字符串        const char *cfileName = fileName.UTF8String;        //3.打开数据库文件（如果数据库文件不存在，那么该函数会自动创建数据库文件）        int result = sqlite3_open(cfileName, &amp;db);        if (result == SQLITE_OK) {//打开成功            NSLog(@&quot;成功打开数据库&quot;);        }else{            NSLog(@&quot;打开数据库失败&quot;);        }    }FMDB方式：        -(void)openDB{        //2、获取数据库连接       db = [FMDatabase databaseWithPath:fileName];        //3、打开数据库连接        if ([db open]) {            NSLog(@&quot;打开数据库成功&quot;);        }else{            NSLog(@&quot;打开数据库失败&quot;);        }    }</code></pre><p>创建表格</p><pre><code>C语言方式    -(void)createTable{        //创建表        const char *sql = &quot;CREATE TABLE IF NOT EXISTS t_student(id integer PRIMARY KEY AUTOINCREMENT,name text NOT NULL,age integer NOT NULL);&quot;;        char *errmsg= NULL;        int result = sqlite3_exec(_db, sql, NULL, NULL, &amp;errmsg);        if (result==SQLITE_OK) {            NSLog(@&quot;创建表成功&quot;);        }else{            NSLog(@&quot;创建表失败---%s&quot;,errmsg);        }    }FMDB方式    -(void)createTable{        BOOL result = [_db executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_student (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL);&quot;];        if (result) {            NSLog(@&quot;创建表格成功&quot;);        }else{            NSLog(@&quot;创建表格失败&quot;);        }    }</code></pre><p>增加数据</p><pre><code>C语言方式    -(void)insertData{        //插入数据        for (int i=0; i&lt;10; i++) {            //拼接sql语句            NSString *name = [NSString stringWithFormat:@&quot;yixiangboy--%d&quot;,arc4random_uniform(100)];            int age = arc4random_uniform(20)+10;            NSString *sql = [NSString stringWithFormat:@&quot;INSERT INTO t_student (name,age) VALUES (&apos;%@&apos;,%d);&quot;,name,age];             //执行SQL语句            char *errmsg = NULL;            sqlite3_exec(db, sql.UTF8String, NULL, NULL, &amp;errmsg);            if (errmsg) {//如果有错误信息                NSLog(@&quot;插入数据失败--%s&quot;,errmsg);            }else{                NSLog(@&quot;插入数据成功&quot;);            }        }    }FMDB方式    -(void)insertData{        for (int i=0; i&lt;10; i++) {            NSString *name = [NSString stringWithFormat:@&quot;yixiang-%d&quot;,arc4random_uniform(100)];            int age = arc4random_uniform(20)+10;            BOOL result = [_db executeUpdate:@&quot;INSERT INTO t_student (name, age) VALUES (?, ?);&quot;,name, @(age)];            if (result) {                NSLog(@&quot;插入成功&quot;);            }else{                NSLog(@&quot;插入失败&quot;);            }        }    }</code></pre><p>删除数据</p><pre><code>C语言方式    -(void)deleteData{        //删除age小于15的数据        NSString *sql = [NSString stringWithFormat:@&quot;DELETE FROM t_student WHERE age&lt;15&quot;];        char *errmsg = NULL;        sqlite3_exec(_db, sql.UTF8String, NULL, NULL, &amp;errmsg);        if (errmsg) {            NSLog(@&quot;删除数据失败&quot;);        }else{            NSLog(@&quot;删除数据成功&quot;);        }    }FMDB方式    -(void)deleteData{         BOOL result = [_db executeUpdate:@&quot;DELETE FROM t_student WHERE age&lt;15&quot;];        if (result) {            NSLog(@&quot;删除成功&quot;);        }else{            NSLog(@&quot;删除失败&quot;);        }    }</code></pre><p>更新数据</p><pre><code>C语言方式    -(void)updateData{         BOOL result = [_db executeUpdate:@&quot;DELETE FROM t_student WHERE age&lt;15&quot;];        if (result) {            NSLog(@&quot;删除成功&quot;);        }else{            NSLog(@&quot;删除失败&quot;);        }    }FMDB方式    -(void)updateData{         BOOL result = [_db executeUpdate:@&quot;UPDATE t_student set age=20 WHERE age&gt;20&quot;];        if (result) {            NSLog(@&quot;更新成功&quot;);        }else{            NSLog(@&quot;更新失败&quot;);        }    }</code></pre><p>查询数据</p><pre><code>C语言方式    -(void) queryData{         const char *sql = &quot;SELECT id,name,age FROM t_student WHERE age&lt;20&quot;;        sqlite3_stmt *stmt = NULL;        //进行查询前的准备工作        if(sqlite3_prepare_v2(_db, sql, -1, &amp;stmt, NULL)==SQLITE_OK){//SQL语句没有问题            NSLog(@&quot;查询语句没有问题&quot;);            //每调用一次sqlite3_step函数，stmt就会指向下一条记录            while (sqlite3_step(stmt)==SQLITE_ROW) {//找到一条记录                //取出数据                //(1)取出第0个字段的值（int）                int ID=sqlite3_column_int(stmt, 0);                //(2)取出第一列字段的值(text)                const unsigned char *name = sqlite3_column_text(stmt, 1);                //(3)取出第二列字段的值(int)                int age = sqlite3_column_int(stmt, 2);                printf(&quot;%d %s %d\n&quot;,ID,name,age);            }        }else{            NSLog(@&quot;查询语句有问题&quot;);        }    }FMDB方式    -(void)queryData{         FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; ?&quot;,@(20)];        while ([resultSet next]) {            int ID = [resultSet intForColumn:@&quot;id&quot;];            NSString *name = [resultSet stringForColumn:@&quot;name&quot;];            int age = [resultSet intForColumn:@&quot;age&quot;];            NSLog(@&quot;%d %@ %d&quot;,ID,name,age);        }    }</code></pre><p>参考资料:<br><br>1.<a href="https://cocoapods.org/pods/FMDB" target="_blank" rel="noopener">FMDB-cocoapods</a><br><br>2.<a href="https://blog.csdn.net/yixiangboy/article/details/51072699" target="_blank" rel="noopener">FMDB和SQLite3对比</a><br><br>3.<a href="http://www.cnblogs.com/polobymulberry/category/789988.html" target="_blank" rel="noopener">FMDB源码阅读</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、FMDB基本信息&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tao1010.github.io/categories/iOS/"/>
    
    
      <category term="iOS第三方库" scheme="http://tao1010.github.io/tags/iOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Python-python基础-PyCharm的使用</title>
    <link href="http://tao1010.github.io/2018/06/26/Python/Python%E5%9F%BA%E7%A1%80/Python-python%E5%9F%BA%E7%A1%80-PyCharm%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://tao1010.github.io/2018/06/26/Python/Python基础/Python-python基础-PyCharm的使用/</id>
    <published>2018-06-26T03:53:53.000Z</published>
    <updated>2018-06-28T13:14:57.875Z</updated>
    
    <content type="html"><![CDATA[<p>一、PyCharm简介</p><pre><code>版本号：2016.2.3</code></pre><a id="more"></a><p>1.特点</p><pre><code>是Python的一款非常优秀的集成开发环境；可以在Windows、Linux、macOS 下使用；适合开发大型项目；    一个项目通常包含很多源文件；    每个源文件的代码行数有限，通常子啊几百行之内；    每个源文件各司其职，共同完成复杂的业务功能；</code></pre><p>2.构成<br><br><img src="pycharm1.png" alt="pycharm1"><br><br>二、PyCharm设置<br><br>1.打开目录</p><pre><code>打开一个项目后，会在目录先新建一个 .idea 的目录，用于保存项目相关信息:    解释器版本    项目包含文件等</code></pre><p><img src="idea.png" alt="idea"><br><br>2.设置项目中运用的 python 解释器版本</p><pre><code>路径:菜单栏PyCharm --&gt; Preferences --&gt;Project... --&gt; Project Interpreter --&gt;选择解释器版本运行配置设置：Run/Debug Configurations --&gt; Python interpreter --&gt; 选择解释器对应的版本</code></pre><p>3.设置字体(控制台和编辑区)</p><pre><code>PyCharm --&gt; Preferences --&gt; Editor --&gt; Colors &amp; Fonts</code></pre><p>4.调试</p><pre><code>Debugger:查看变量信息Console:查看输出信息之前调试未关闭，再次点击调试按钮 会在控制台新开启调试窗口</code></pre><p>三、新建项目<br><br>1.命名规则</p><pre><code>建议只使用小写字母、数字、下划线不能以数字开始</code></pre><p>2.新建项目</p><pre><code>菜单栏：File --&gt; New Project...</code></pre><p>3.注释</p><pre><code>单行注释 # 解释器不会解释 # 号右侧的代码# 放在代码行首 建议在 # 后添加一个空格 或者 command + / 添加注释# 放在代码行尾 建议在 # 空格前空2格多行注视或块注释&quot;&quot;&quot;  这是一个多行注释 &quot;&quot;&quot;</code></pre><p>参考资料:<br><br>1.<a href="">黑马视频</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、PyCharm简介&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;版本号：2016.2.3
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://tao1010.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python-python基础-第一个程序</title>
    <link href="http://tao1010.github.io/2018/06/26/Python/Python%E5%9F%BA%E7%A1%80/Python-python%E5%9F%BA%E7%A1%80-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
    <id>http://tao1010.github.io/2018/06/26/Python/Python基础/Python-python基础-第一个程序/</id>
    <published>2018-06-26T02:27:11.000Z</published>
    <updated>2018-06-26T15:42:29.386Z</updated>
    
    <content type="html"><![CDATA[<p>1.基本概念</p><a id="more"></a><pre><code>Python程序文件扩展名 通常是 .py；Pyhton源程序是一个特殊格式的文本文件，可用任意文本编辑软件做Python的开发；</code></pre><p>2.创建python程序<br><br>方法一：终端</p><pre><code>打开终端工具,在桌面创建文件夹python demo    cd /Users/xxx/Desktop #切换到桌面    mkdir python demo      #创建文件夹创建python1.py文件    cd python demo    touch python1.py     #创建python1文件    vim python1.py       #开始编辑文件    i                        #切换到编辑模式    #编辑python程序代码        print(&quot;Hello python&quot;)        print(&quot;Hello world&quot;)    ################    esc                        #退出编辑模式    :wq                        #保存并退出python1.py文件执行python1.py文件    python python1.py    #执行python1.py文件此时可在终端看到输出的内容</code></pre><p>3.常见错误</p><pre><code>语法错误 SyntaxError    拼写错误    一行代码多件事情的处理的情况 --- 每行代码执行一个动作python2.x默认不支持中文缩进错误 IndentationError    每行代码顶格输入</code></pre><p>4.python2.x和3.x区别</p><pre><code>python2.x 的解释器名称 python - 不支持中文python3.x 的解释器名称 python3 - 支持中文    只是在2.0的基础上修改了底层实现代码，所以2.x--&gt;3.x工作量不大建议使用3.0的语法，设计2.0的时候不考虑向下兼容如果开发时，无法立即使用Pyhon3.0，建议使用Python3.0开发，然后使用Python2.6、2.7执行，并且做一些兼容处理。</code></pre><p>5.执行Python程序的三种方式<br><br>解释器运行Python程序</p><pre><code>Python解释器    python xxx.py    #使用python 2.x 解释器    python3 xxx.py #使用python 3.x 解释器其他解释器    CPython 官方版本的C语言实现    Jython 可以运行在JAVA平台    IronPython 可以运行在.NET和Mono平台    PyPy Python实现，支持JIT即时编译</code></pre><p>交互式运行Python程序    </p><pre><code>步骤：    终端输入:python #进入Python2.x Shell环境    输入命令代码：        print(&quot;Hello world&quot;) # 回车    退出：        方式一: exit()        方式二: control + d特点：    直接在终端中运行解释器，不输入要执行的文件名；    在python的Shell中直接输入Python代码，会立即看到程序执行的结果；适用：    学习和验证python语法或局部代码缺点：    代码不能保存；    不适合运行太大的程序；IPython    IPython(interactive python)是一个python的交互式shell    特点：        支持自动补全；        自动缩进；        支持bash shell命令；        内置了许多有用的功能和函数；    版本：        ipyhton #python2.x        ipyhton3 # python3.x    退出：        control + d 或者 exit</code></pre><p>Python的IDE - PyCharm</p><pre><code>集成开发环境(IDE,intergrated development environment)    图形用户界面；    代码编辑器；(支持 代码补全，自动缩进)    编辑器/解释器；    调试器；(断点/单步执行)    ...PyCharm特点:    可以在Windows、Linux、macOS 下使用；    适合开发大型项目；</code></pre><p>参考资料:<br><br>1.<a href="">黑马视频</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.基本概念&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://tao1010.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python-python基础-简介</title>
    <link href="http://tao1010.github.io/2018/06/26/Python/Python%E5%9F%BA%E7%A1%80/Python-python%E5%9F%BA%E7%A1%80-%E7%AE%80%E4%BB%8B/"/>
    <id>http://tao1010.github.io/2018/06/26/Python/Python基础/Python-python基础-简介/</id>
    <published>2018-06-26T01:42:18.000Z</published>
    <updated>2018-06-26T15:42:29.388Z</updated>
    
    <content type="html"><![CDATA[<p>1.解释器</p><pre><code>编译器:将其他语言翻译成机器语言的工具；    全部编译完成，最后生成机器语言统一执行；    使用某平台编译器，生成的可执行文件只能在该平台执行；    程序执行效率高，依赖编译器，跨平台性差；编译器翻译的方式：编译 + 解释    两种方式的区别：翻译时间点不同；解释器：当编译器以解释方式运行的时候称为解释器;    不进行预编译，以文本方式存储程序代码；    解释一行，执行一行；    执行速度慢；    不同的操作系统安装不同解释器，源代码可跨平台运用；</code></pre><a id="more"></a><p><img src="python.png" alt="python"><br><br>2.Python设计目标</p><pre><code>简单直观，功能强大；开源；代码易理解；开发项目周期短；</code></pre><p>3.Python特点</p><pre><code>完全面对对象的语言    一切皆对象(函数、模块、数字、字符串等等都是对象)；    完成支持继承、重载、多重继承；    支持重载字符串，支持泛型设计；拥有强大的标准库    系统管理；    网络通信；    数据库接口；    图形系统；    XML处理等大量的第三方模块    科学计算；    人工智能；    机器学习；    Web开发；    数据库接口；    图形系统等</code></pre><p>优点：</p><pre><code>简单、易学；免费、开源；面向对象；丰富的库；可扩展性；    C或C++编写核心代码(运行更快)或不公开算法</code></pre><p>缺点：        </p><pre><code>运行速度比编译性语言慢； - 可扩展性可解决此问题国内市场小；中文资料少；</code></pre><p>4.面向对象的思维方式</p><pre><code>解决问题前，考虑 谁 来做，(具体怎么做是 谁 的职责)，最后把事情做好就行！解决复杂问题，可以找多个不同对象，各司其职，共同实现，最终完成需求！</code></pre><p>参考资料:<br><br>1.<a href="">黑码视频</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.解释器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;编译器:将其他语言翻译成机器语言的工具；
    全部编译完成，最后生成机器语言统一执行；
    使用某平台编译器，生成的可执行文件只能在该平台执行；
    程序执行效率高，依赖编译器，跨平台性差；
编译器翻译的方式：编译 + 解释
    两种方式的区别：翻译时间点不同；

解释器：当编译器以解释方式运行的时候称为解释器;
    不进行预编译，以文本方式存储程序代码；
    解释一行，执行一行；
    执行速度慢；
    不同的操作系统安装不同解释器，源代码可跨平台运用；
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="python基础" scheme="http://tao1010.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Swift-Documents-UIKit</title>
    <link href="http://tao1010.github.io/2018/06/26/Swift/Documents/Swift-Documents-UIKit/"/>
    <id>http://tao1010.github.io/2018/06/26/Swift/Documents/Swift-Documents-UIKit/</id>
    <published>2018-06-26T01:21:01.000Z</published>
    <updated>2018-06-26T15:42:29.393Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>参考资料:<br><br>1.<a href="https://developer.apple.com/documentation/uikit/about_app_development_with_uikit#3004316" target="_blank" rel="noopener">UIKit</a><br><br>2.<a href="https://developer.apple.com/documentation/" target="_blank" rel="noopener">Documents</a><br><br>3.<a href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009247" target="_blank" rel="noopener">Information Property List Key Reference</a><br><br>4.<a href="https://www.jianshu.com/p/37721fa4b860" target="_blank" rel="noopener">类-Class和结构体-Struct的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;参考资料:&lt;br&gt;&lt;br&gt;1.&lt;a href=&quot;https://developer.apple.com/documentation/uikit/about_app_development_with_uikit#3004316&quot; targe
      
    
    </summary>
    
      <category term="iOS" scheme="http://tao1010.github.io/categories/iOS/"/>
    
    
      <category term="swift" scheme="http://tao1010.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Python-linux基础-系统信息</title>
    <link href="http://tao1010.github.io/2018/06/25/Python/Linux%E5%9F%BA%E7%A1%80/Python-linux%E5%9F%BA%E7%A1%80-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"/>
    <id>http://tao1010.github.io/2018/06/25/Python/Linux基础/Python-linux基础-系统信息/</id>
    <published>2018-06-25T03:06:13.000Z</published>
    <updated>2018-06-26T15:42:29.376Z</updated>
    
    <content type="html"><![CDATA[<p>一、系统信息</p><a id="more"></a><p>1.系统日期和时间</p><pre><code>date #查看系统时间cal  #calendar查看日历，-y选项可以查看一年的日历</code></pre><p>2.磁盘空间</p><pre><code>df -h  #disk free显示磁盘剩余空间du -h[目录名] #disk usage 显示目录下的文件大小-h选项 表示以人性化方式显示文件大小</code></pre><p>3.进程信息 (正在执行的程序)</p><pre><code>ps aux              #process status 查看进程的详细状况    a    显示终端上的所有进程，包括其他用户的进程    u    显示进程的详细状态    x    显示没有控制终端的进程top                  #动态显示运行中的进程并且排序    要退出 top命令 输入 q 即可kill [-9] 进程代码 #终止指定代号PID的进程，-9表示强行终止     最好只终止由当前用户开启的进程，不要终止由root身份开启的进程,否则可能导致系统crasheg：kill 4179     kill -9 4179</code></pre><p>二、其他命令</p><p>1.查找文件 - find</p><pre><code>格式:    find [路径] -name “*.py” #查找指定路径下扩展名是 .py 的文件 包括子目录eg:    find -name &quot;*.png&quot;    find Desktop/ -name &quot;*1*&quot;tip：    如果省略路径，表示在当前文件夹下查找；</code></pre><p>2.文件软链接 - ln    </p><pre><code>格式：    ln -s 被链接的源文件 链接文件 #建立文件的软链接，类似于快捷方式tips：    没有 -s 选项建立的是一个硬链接文件；    源文件使用绝对路径，不能使用相对路径，这样移动链接文件后，仍能正常使用；eg:    ln -s test/1.txt 02 #相对路径 不可用    ln -s /Users/xxx/Desktop/test2/1.txt 01 #绝对路径 可用在Linux中，文件名和文件数据是分开存储的；硬链接：文件的另外一个名字，需要把硬链接所有的文件名删除，才能删除文件数据；软链接：文件的绝对路径，从未访问文件的数据；</code></pre><p>3.打包压缩 tar</p><pre><code>Windows 常用rarMac 常用zipLinux 常用 tar.gztar 是Linux中最常用的备份工具，只打包，不压缩；格式:    #打包文件    tar -cvf 打包文件.tar 被打包的文件/路径...    #解包文件    tar -xvf 打包文件.tartar选项说明：    c    生成档案文件，创建打包文件    x    解开档案文件    v    列出归档解档的详细过程，显示进度    f    指定档案文件名称，f后面一定是.tar文件 必须放在选项最后(cxv的顺序可任意调换)eg：    tar -cvf test.tar 1.pdf 2.py 2.txt #在当前目录中将1.pdf、2.py、2.txt三个文件 打包为 test.tar包        tar -xvf test.tar #解包</code></pre><p>4.压缩和解压缩 <br><br>方法一：</p><pre><code>tar和gzip 命令结合可以实现文件的打包和压缩用gzip 压缩tar打包后的文件，其扩展名一般用xxx.tar.gz格式：    压缩文件    tar -zcvf 打包文件.tar.gz 被压缩的文件/路径...    解压缩文件    tar -zxvf 打包文件.tar.gz    解压缩到指定路径    tar -zxvf 打包文件.tar.gz -C 目标路径    选项    -C 解压缩到指定目录(要解压缩的目录必须存在）eg:    tar -zcvf test1.tar.gz 1.pdf 2.py 2.txt</code></pre><p>方法二：</p><pre><code>tar和bzip2 命令结合可以实现文件 打包和压缩用bzip2压缩tar打包后的文件，其扩展名一般用xxx.tar.bz2格式：    压缩文件    tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径...    解压文件    tar -jxvf 打包文件.tar.bz2eg:    tar -jcvf test.tar.bz2 1.pdf 2.py 2.txt    tar -jxvf test.tar.bz2</code></pre><p>4.安装软件     apt-get</p><pre><code>apt 是Advanced Packaging Tool是Linux下的一款安装包管理工具；     可以在终端方便的 安装、卸载、更新软件包；安装软件:sudo apt install 软件包卸载软件：sudo apt remove 软件名更新软件:(更新已安装的包)sudo apt upgrade        </code></pre><p>5.配置软件源</p><pre><code>软件源镜像源：所有服务器的内容是相同的，但是根据所在位置不同，国内服务器通常更快</code></pre><p>参考资料:<br>1.<a href="https://pan.baidu.com/s/1o3eZ1nJTKDi4PRZpeUizgw" target="_blank" rel="noopener">黑马视频 - 密码:m8tu</a><br><br>2.<a href="https://blog.csdn.net/xicikkk/article/details/53447025" target="_blank" rel="noopener">在Mac OS X上开启ssh服务</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、系统信息&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="linux" scheme="http://tao1010.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python-linux基础-用户管理</title>
    <link href="http://tao1010.github.io/2018/06/25/Python/Linux%E5%9F%BA%E7%A1%80/Python-linux%E5%9F%BA%E7%A1%80-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://tao1010.github.io/2018/06/25/Python/Linux基础/Python-linux基础-用户管理/</id>
    <published>2018-06-25T02:02:42.000Z</published>
    <updated>2018-06-26T15:42:29.371Z</updated>
    
    <content type="html"><![CDATA[<p>一、用户管理</p><a id="more"></a><pre><code>用户管理包括用户和组的管理</code></pre><p>1.创建用户/设置密码/删除用户</p><pre><code>终端命令都需要使用sudo执行增加新用户：    useradd -m -g 组 新建用户名     # -m自动建立用户家目录     # -g指定用户所在的组，否则会建立一个和同名的组    eg: sudo useradd -m -g dev deng #表示在dev群组下创建一个deng的新用户设置密码：    passwd 用户名 #普通用户直接使用passwd可以修改自己密码    eg:sudo passwd deng删除用户：    userdel -r 用户名 #-r选项会自动删除用户家目录    eg:sudo userdel -r deng确认用户信息：    cat /etc/passwd|grep 用户名 #新建用户后，用户信息会保存在 /etc/passwd 文件中    eg：cat -n /etc/passwd #-n表示显示行号的家目录信息列表        cat -n /etc/passwd | grep deng #显示deng的用户信息passwd文件    /etc/passwd 文件存放的是用户的信息，由6个分号组成的7个信息：        1.用户名        2.密码(x,表示加密的密码)        3.UID(用户标识)        4.GID(组标识)        5.用户全名或本地账号        6.家目录        7.登录使用的Shell，即登录之后使用的终端命令，ubutu默认dash</code></pre><p>2.查看用户信息</p><pre><code>查看用户UID和GID信息：    id [用户名] #G group组查看当前所有登录的用户列表：    who 查看当前登录用户的账户名：    whoami</code></pre><p>3.usermod<br><br>设置主组和附加组</p><pre><code>主组：通常在新建用户组时指定，在/etc/passwd 的第4列GID对应的组；附加组：在etc/group 中最后一列表示该组的用户列表，用于指定用户的附加权限修改用户的主组（g）usermod -g 组 用户名修改用户的附加组（G）usermod -G 组 用户名</code></pre><p>指定用户登录shell(shell 即为终端)</p><pre><code>修改用户登录shellusermod -s /bin/bash</code></pre><p>tips</p><pre><code>设置了附加组后，需要重新登录才能生效；默认使用 useradd 添加的用户没有权限使用 sudo，以root身份执行命令的，可以使用以下命令将用户添加到sudo 附加组中    usermod -G sudo 用户名</code></pre><p>4.which</p><pre><code>用于查看执行命令所在的位置eg:    which ls    which useradd/etc/passwd          用于保存用户信息的文本文件/usr/bin/passwd     用于修改用户密码的程序验证: 查看对应文件权限     ls -l /usr/bin/passwd    ls -l /etc/passwd</code></pre><p>bin和sbin</p><pre><code>在Linux中，绝大多数可执行文件都是保存在 /bin、/sbin、/usr/bin、/usr/sbin/bin (binary)是二进制执行文件目录，主要用于具体应用/sbin    (system binary)是系统管理员专用的二进制代码存放目录，主要用于系统管理/usr/bin (user commands for applications)后期安装的一些软件/usr/sbin (super user commands for applications)超级用户的一些管理程序</code></pre><p>5.切换用户 su</p><pre><code>格式：    su -用户名   #切换用户，并且切换目录 ， - 的作用：可以切换到用户家目录，否则保持位置不变    exit 退出当前登录账户su 不接用户可以切换到root，但是不推荐使用，因为不安全</code></pre><p><img src="exit.png" alt="exit"><br><br>6.修改文件权限</p><pre><code>chown 修改文件/目录的拥有者chgrp 修改文件/目录的组chmod 修改文件/目录的权限格式：chown 用户名 文件名|目录名chgrp -R 组名 文件名|目录名#-R递归修改文件|目录组chmod -R 755 文件名|目录名        7 文件或目录拥有者的权限         5 文件或目录组成员的权限         5 文件或目录其他组成员的权限 </code></pre><p>chmod设置权限时，可以简单的使用三个数字分别对应 拥有者 / 组 / 其他 用户的权限<br><br>chmod +/-rwx 文件名|目录名 #直接修改文件|目录的 读|写|执行 权限。但不能精确到拥有者 / 组 / 其他<br><br><img src="auth.png" alt="auth"><br></p><pre><code>eg:        777 u=rwx, g=rwx, o=rwx    755 u=rwx, g=rx,  o=rx    644 u=rw,  g=r,   o=r    000 u=-,      g=-,   o=-eg1:chmod -R 777 01.py</code></pre><p>参考资料:<br>1.<a href="https://pan.baidu.com/s/1o3eZ1nJTKDi4PRZpeUizgw" target="_blank" rel="noopener">黑马视频 - 密码:m8tu</a><br><br>2.<a href="https://blog.csdn.net/xicikkk/article/details/53447025" target="_blank" rel="noopener">在Mac OS X上开启ssh服务</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、用户管理&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="linux" scheme="http://tao1010.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac安装Ubuntu</title>
    <link href="http://tao1010.github.io/2018/06/22/%E5%85%B6%E4%BB%96/Mac%E5%AE%89%E8%A3%85Ubuntu/"/>
    <id>http://tao1010.github.io/2018/06/22/其他/Mac安装Ubuntu/</id>
    <published>2018-06-22T06:02:44.000Z</published>
    <updated>2018-06-22T12:37:04.412Z</updated>
    
    <content type="html"><![CDATA[<p>1.<a href="https://www.ubuntu.com/download/desktop" target="_blank" rel="noopener">下载Ubuntu</a><br></p><font color="red">未成功，待进进一步尝试…</font><a id="more"></a><p>2.磁盘分区</p><pre><code>1.打开 Mac 中的磁盘工具；2.选择最外层磁盘，点击工具栏上的 分区；3.编辑分区的名称 &quot;Linux&quot; 和 设置分区大小 60G；4.点击应用，等待分区完成。</code></pre><p><img src="ubuntu1.png" alt="ubuntu1"><br><br><img src="ubuntu2.png" alt="ubuntu2"><br><br>3.ubuntu.iso转换成dmg格式</p><pre><code>cd xxx/test/ #test文件夹下放置之前下载的ubuntu-18.04-desktop-amd64.iso 文件 hdiutil convert ubuntu-18.04-desktop-amd64.iso -format UDRW -o ubuntu.dmg </code></pre><p>4.制作启动盘</p><pre><code>1.插入U盘2.终端：    diskutil list #查看mac下磁盘序号</code></pre><p><img src="disk.png" alt="disk"><br>        </p><pre><code>3.终端：将 N 改成U盘序号(通常是1或2，上述2结果中的序号)    diskutil unmountDisk /dev/diskN    显示：    Unmount of all volumes on disk1 was successful4.终端：将 N 改成U盘序号(通常是1或2，上述2结果中的序号)    sudo dd if=ubuntu.dmg of=/dev/rdiskN bs=2m    显示：    Password:    916+1 records in    916+1 records out    1921843200 bytes transferred in 304.902708 secs (6303136 bytes/sec)5.终端：退出U盘，将 N 改成U盘序号(通常是1或2，上述2结果中的序号)diskutil eject /dev/diskN显示：Disk /dev/disk1 ejected</code></pre><p>5.安装Mac的引导工具 Refind</p><p>参考资料：<br><br>1.<a href="http://www.cnblogs.com/diligenceday/p/6103530.html" target="_blank" rel="noopener">mac上安装ubuntu双系统</a><br><br>2.<a href="https://www.linuxidc.com/Linux/2017-04/143112.htm" target="_blank" rel="noopener">在 MacBook Pro 上安装 Ubuntu 16.04.1 LTS</a><br><br>3.<a href="https://www.cnblogs.com/diligenceday/p/6103530.html" target="_blank" rel="noopener">Mac上安装ubuntu</a><br><br>4.<a href="https://blog.csdn.net/babytang008/article/details/70879634" target="_blank" rel="noopener">Mac OS + Ubuntu + Windows</a><br><br>5.<a href="https://blog.csdn.net/xiaoshaxs?t=1" target="_blank" rel="noopener">Mac引导工具 Refind</a><br><br>6.<a href="http://www.pc6.com/mac/113059.html" target="_blank" rel="noopener">Refind</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.&lt;a href=&quot;https://www.ubuntu.com/download/desktop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载Ubuntu&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
&lt;font color=&quot;red&quot;&gt;未成功，待进进一步尝试…&lt;/font&gt;
    
    </summary>
    
      <category term="其他" scheme="http://tao1010.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="系统" scheme="http://tao1010.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架-组件-深入了解组件</title>
    <link href="http://tao1010.github.io/2018/06/22/vue%E6%A1%86%E6%9E%B6/Vue%E6%A1%86%E6%9E%B6-%E7%BB%84%E4%BB%B6-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6/"/>
    <id>http://tao1010.github.io/2018/06/22/vue框架/Vue框架-组件-深入了解组件/</id>
    <published>2018-06-22T03:07:53.000Z</published>
    <updated>2018-06-22T12:37:04.411Z</updated>
    
    <content type="html"><![CDATA[<p>一、组件注册<br><br>1.组件名</p><a id="more"></a><pre><code>Vue.componnet(&apos;my-componnet-name&apos;,{/*...*/})第一个参数即为自定义组件名；定义组件名：    1.推荐：使用kebab-case        字母全部小写，必须包含连字符 ‘-’        直接在DOM（非字符串的模版）使用只有kebab-case 有效    2.使用PascalCase(驼峰式命名)         首字母大写</code></pre><p>2.全局注册</p><p>3.局部注册</p><pre><code>全局注册往往是不够理想的：    当不再使用一个组件时，若为全局注册，仍然会被包含在最终的构建结果中。</code></pre><p>二、Prop<br></p><p>三、自定义事件<br></p><p>四、插槽<br></p><p>五、动态组件和异步组件<br></p><p>六、处理边界情况<br></p><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org/v2/guide/components-registration.html" target="_blank" rel="noopener">深入了解组件</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、组件注册&lt;br&gt;&lt;br&gt;1.组件名&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架-组件-基础</title>
    <link href="http://tao1010.github.io/2018/06/22/vue%E6%A1%86%E6%9E%B6/Vue%E6%A1%86%E6%9E%B6-%E7%BB%84%E4%BB%B6-%E5%9F%BA%E7%A1%80/"/>
    <id>http://tao1010.github.io/2018/06/22/vue框架/Vue框架-组件-基础/</id>
    <published>2018-06-22T01:11:46.000Z</published>
    <updated>2018-06-22T12:37:04.411Z</updated>
    
    <content type="html"><![CDATA[<p>一、组件基础<br><br>1.基本示例</p><pre><code>组件是可复用的Vue实例，与new Vue接收相同的选项(data、computed、watch、methods、生命周期钩子等)，仅有像el这样根实例特有的选项。</code></pre><a id="more"></a><pre><code>&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;p&gt;自定义组件&lt;/p&gt;        &lt;button-counter&gt;&lt;/button-counter&gt;    &lt;/div&gt;    &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;    &lt;script&gt;       // 定义一个名为button-counter 的新组件       Vue.component(&apos;button-counter&apos;, {           data: function(){               return {                   count: 0               }           },           template: &quot;&lt;button v-on:click=&apos;count++&apos;&gt; You clicked me {{ count }} times.&lt;/button&gt;&quot;       })       var vm = new Vue({           el: &apos;#app&apos;       });    &lt;/script&gt;&lt;/body&gt;tips：    在&lt;script&gt;&lt;/script&gt;中，创建自定义组件在前，使用在后：        1.Vue.component(&apos;xxx&apos;, {...});        2.var vm = new Vue({...})</code></pre><p>2.组件复用<br><br>一个组件的 data 选项 必须是一个函数</p><pre><code>组件复用时，每个组件都会各自独立维护它的count，因为每用一次组件，就会有一个新的实例被创建每个实例维护一份被返回对象的独立的拷贝</code></pre><p>3.组件的组织</p><pre><code>通常一个应用会以一颗嵌套的组件树的形式来组织；组件必须先注册以便Vue能够识别：    全局注册和局部注册    全局注册的组件可以用在其被注册之后的任何(通过new Vue)新创建的Vue根实例，包括组件树中的所有子组件的模版中。</code></pre><p>4.通过Prop向子组件传递数据</p><pre><code>一个组件默认可以拥有任意数量的prop，任何值都可以传递给任何prop可以使用 v-bind 来动态传递propeg:&lt;div id=&quot;app2&quot;&gt;    &lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;    &lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;    &lt;blog-post title=&quot;Why Vue is so fun&quot;&gt;&lt;/blog-post&gt;    &lt;br&gt;    &lt;blog-post v-for=&apos;post in posts&apos; v-bind:key=&apos;post.id&apos; v-bind:title=&apos;post.title&apos;&gt;&lt;/blog-post&gt;&lt;/div&gt;&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;&lt;script&gt;   // 定义一个名为button-counter 的新组件   Vue.component(&apos;blog-post&apos;,{       props:[&apos;title&apos;],       template: &apos;&lt;h3&gt;{{title}}&lt;/h3&gt;&apos;   });   var vm1 = new Vue({       el: &quot;#app2&quot;,       data: {           posts: [               {id: 1,title: &apos;My journey with Vue&apos;},               {id: 2,title: &apos;Blogging with Vue&apos;},               {id: 3,title: &apos;Why Vue is so fun&apos;}           ]       }   });&lt;/script&gt;</code></pre><p>5.单个根元素</p><pre><code>每个组件必须只有一个根元素；不论何时为 post 对象添加一个新的属性，它都会自动地在 &lt;blog-post&gt; 内可用；需要在不 (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE，请使用折行转义字符取而代之；eg:修改自定义组件 templateVue.component(&apos;blog-post&apos;, {      props: [&apos;post&apos;],      template: `        &lt;div class=&quot;blog-post&quot;&gt;          &lt;h3&gt;{{ post.title }}&lt;/h3&gt;          &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;        &lt;/div&gt;      `})</code></pre><p>6.通过事件向父级组件发送消息<br><br>eg:增大博文的字号    </p><pre><code>自定义组件：Vue.component(&apos;blog-post&apos;,{   props:[&apos;post&apos;],   template: `    &lt;div class=&quot;blog-post&quot;&gt;        &lt;h3&gt;{{ post.title }}&lt;/h3&gt;        &lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;)&quot;&gt;            Enlarge text        &lt;/button&gt;        &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    `});在其父组件中，通过添加一个 postFontSize 数据属性来支持这个功能；var vm1 = new Vue({   el: &quot;#app2&quot;,   data: {       posts: [           {id: 1,title: &apos;My journey with Vue&apos;},           {id: 2,title: &apos;Blogging with Vue&apos;},           {id: 3,title: &apos;Why Vue is so fun&apos;}       ],       postFontSize: 1   }});在模版中控制所有博文的字号：&lt;div :style = &quot;{fontSize: postFontSize + &apos;em&apos;}&quot;&gt;    &lt;blog-post v-for=&apos;post in posts&apos;                v-bind:key=&apos;post.id&apos;                v-bind:post=&apos;post&apos;               v-on:enlarge-text=&quot;postFontSize +=0.1&quot;&gt;    &lt;/blog-post&gt;&lt;/div&gt;调用内建的 $emit 方法并传入事件的名字，来向父级组件触发一个事件;自定义组件中:    &lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;)&quot;&gt;        Enlarge text    &lt;/button&gt;用 v-on 在组件上监听这个事件，就像监听一个原生 DOM 事件一样;使用组件时：     v-on:enlarge-text=&quot;postFontSize +=0.1&quot;</code></pre><p>使用事件抛出一个值</p><pre><code>组件决定文本要放大多少，使用 $emit 的第二个参数提供在父级组件监听这个事件，通过 $even 访问被抛出的值</code></pre><p>在组件上使用v-model</p><pre><code>自定义事件也可以用于创建支持 v-model 的自定义输入组件；</code></pre><p>7.通过插槽分发内容<br><br><a href="https://cn.vuejs.org/v2/guide/components-slots.html" target="_blank" rel="noopener">插槽</a><br><br>8.动态组件<br><br><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html" target="_blank" rel="noopener">动态和异步组件</a></p><p>9.解析DOM模板时的注意事项</p><pre><code>有些 HTML 元素，诸如 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的;有些元素，诸如 &lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;，只能出现在其它某些特定的元素内部;如果我们从以下来源使用模板的话，这条限制是不存在的：    字符串 (例如：template: &apos;...&apos;)    单文件组件 (.vue)    &lt;script  type=&quot;text/x-template&quot;&gt;</code></pre><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">Vue - 组件</a><br><br>2.<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">单文件组件</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、组件基础&lt;br&gt;&lt;br&gt;1.基本示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;组件是可复用的Vue实例，与new Vue接收相同的选项(data、computed、watch、methods、生命周期钩子等)，仅有像el这样根实例特有的选项。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Python-linux基础-用户权限</title>
    <link href="http://tao1010.github.io/2018/06/21/Python/Linux%E5%9F%BA%E7%A1%80/Python-linux%E5%9F%BA%E7%A1%80-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/"/>
    <id>http://tao1010.github.io/2018/06/21/Python/Linux基础/Python-linux基础-用户权限/</id>
    <published>2018-06-21T06:22:11.000Z</published>
    <updated>2018-06-26T15:42:29.339Z</updated>
    
    <content type="html"><![CDATA[<p>一、SSH高级<br></p><a id="more"></a><p>1.终端中查看 .ssh 目录<br><br><img src="ssh3.png" alt="ssh"><br>    有关SSH配置信息都保存在用户家目录下的 .ssh 目录下</p><pre><code>ls-alh #查看隐藏目录cd .ssh #进入 .ssh 目录中ls -alh #查看目录文件    已知主机文件 known_hosts</code></pre><p>2.远程连接<br><br><img src="ssh.png" alt="ssh">    </p><pre><code>在Mac电脑的 系统便好设置 中，点击 共享 后，勾选 远程登录 即可启用SSH服务可通过如下命令远程登录：    ssh xxx@192.168.xx.xxx    yes/no     #是否授权    password    #输入需要远程服务器密码终端命令:exit #退出远程登录</code></pre><p>3.免密登录<br><br>步骤：</p><pre><code>1.配置公钥    ssh-keygen    #生成 公钥和私钥 输入文件名:xxx 和对应公钥的密码:***，即可生成：xxx.pub 的公钥文件和 xxx的私钥文件 可以直接回车，不输入任何信息，默认生成id_rsa.pub 的公钥文件和id_rsa的私钥文件2.上传公钥到服务器    ssh-copy-id -p port user@remote #让服务器记住公钥,会将xxx.pub文件保存在远程服务器家目录下的 .ssh 目录下    完成上述步骤后，在此登录远程服务器时不需要输入密码。        cat xxx.pub #此命令可以查看公钥信息</code></pre><p>4.免密登录原理<br><br><img src="ssh2.png" alt="ssh2"><br></p><pre><code>公钥：xxx.pub  默认生成 id_rsa.pub私钥：xxx         默认生成 id_rsa非对称加密算法：    使用 公钥 加密的数据，需要使用 私钥 解密；    使用 私钥 加密的数据，需要使用 公钥 解密使用过程:    客户端--&gt;服务器    客户端将 数据A 通过 私钥 加密后，上传服务器，    服务器接收 数据A 后，使用 公钥 解密;服务器--&gt;客户端    服务器将 数据B 通过 公钥 加密后，下发到客户端，    客户端接收 数据B 后，使用 私钥 解密;</code></pre><p>5.配置别名<br></p><pre><code>优点：    ssh -p port user@remote &lt;===&gt; ssh xxx(别名)步骤:    1.在家目录下的.ssh目录下新建config文件；        cd .ssh        touch config        gedit config #貌似无效    2.编辑config文件内容:        Host xxx(别名)            HostName ip地址 #远程服务器的ip地址            User 用户名 #远程计算机的用户名            Port 22    3.保存文件，即可使用别名远程登录或scp复制文件等。        ssh xxx #即可远程登录        exit    #退出远程登录        scp -r ~/Desktop xxx:Desktop/Demo #将本地桌面的所有文件 复制到 远程计算机 桌面上 Demo文件夹下</code></pre><p>二、用户权限<br></p><pre><code>在Linux中，每个系统(本机或远程登录系统)必须拥有一个账号，并对于不同系统资源拥有不同的使用权限；在Linux中，可以指定每一个用户针对不同的文件或者 目录的不同权限；在实际运用中，预先对组设置好权限，然后将不同的用户添加到对于的组中，而不用依次为每个用户设置权限；对文件或目录的权限：    r    read        4(数字代码)        读    w    write        2                写    x    excute        1                执行</code></pre><p>1.ls -l命令扩展(查看文件详细信息列表)<br><br><img src="lsl.jpg" alt="lsl"><br><br><img src="lsl2.png" alt="lsl2"><br></p><pre><code>硬链接数： 表示有多少种方式访问到当前的文件或目录</code></pre><font color="red">2.chmod - 修改权限</font><pre><code>chmod 可以修改用户/组 对文件/目录的权限格式:    chmod +/-rwx 文件名/目录名 #+表示增加权限，-表示减少权限该方式会一次性修改 拥有者和组权限 执行文件格式：（文件当前目录下执行）    ./文件名</code></pre><p>3.root - 超级用户</p><pre><code>Linux系统中，root账户通常用于系统的维护和管理，对操作系统的所有资源具有所有访问权限；大多数版本的Linux中，不推荐 直接使用root账号登录系统；在Linux安装过程中，系统会自动创建一个标准用户账号sudo    su substitute user 的缩写 表示使用另一个用户身份；    sudo 命令用来以其他身份执行命令，预设身份 root；    用户使用sudo，必须先输入密码，之后5分钟有效；    未授权用户使用sudo，则会发警告邮件给管理员；</code></pre><p>三、组管理<br><br>1.创建和删除组</p><pre><code>对组操作的终端命令需要通过sudo执行组信息保存在 /etc/group文件中/etc 目录是专门用来保存系统配置信息的目录添加组：    groupadd 组名    eg:sudo groupadd dev删除组：    groupdel 组名    eg:sudo groupdel dev确认组信息:    cat /etc/group修改文件/目录的所属组：    chgrp 组名 文件/目录名递归修改文件/目录的所属组：    chgrp -R 组名 文件/目录名 </code></pre><p>参考资料:<br>1.<a href="https://pan.baidu.com/s/1o3eZ1nJTKDi4PRZpeUizgw" target="_blank" rel="noopener">黑马视频 - 密码:m8tu</a><br><br>2.<a href="https://blog.csdn.net/xicikkk/article/details/53447025" target="_blank" rel="noopener">在Mac OS X上开启ssh服务</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、SSH高级&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="linux" scheme="http://tao1010.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架-基础-表单</title>
    <link href="http://tao1010.github.io/2018/06/21/vue%E6%A1%86%E6%9E%B6/Vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-%E8%A1%A8%E5%8D%95/"/>
    <id>http://tao1010.github.io/2018/06/21/vue框架/Vue框架-基础-表单/</id>
    <published>2018-06-21T01:11:33.000Z</published>
    <updated>2018-06-22T12:37:04.410Z</updated>
    
    <content type="html"><![CDATA[<p>一、基础用法<br><br>使用 v-model 指令在表单 &lt;input&gt; 及 &lt;textarea&gt; 元素上创建双向数据绑定；</p><a id="more"></a><pre><code>它会更具控件类型自动选取正确的方法来更新元素；v-model负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理；</code></pre><p>tips:</p><pre><code>v-model 会忽略所有表单元素的value、checked、selected特性的初始值；v-model总是将Vue实例的数据作为数据来源，应该通过JavaScript在组件的 data 选项中声明初始值；需要使用输入法的语言，v-model不会在输入法组合文字过程中得到更新，如需处理此问题，使用 input 事件；v-model绑定的值通过是静态字符串,对于复选框也可以是布尔值；</code></pre><p>1.文本</p><pre><code>&lt;body&gt;    &lt;div id=&quot;example1&quot;&gt;        &lt;input v-model=&apos;message&apos; placeholder=&quot;编辑&quot;&gt;        &lt;p&gt;Message is: {{message}}&lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        var vm = new Vue({            el: &quot;#example1&quot;,            data:{                message: &apos;测试一下&apos;            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>2.多行文本</p><pre><code>&lt;body&gt;    &lt;div id=&quot;example2&quot;&gt;        &lt;span&gt;Multiline message is:&lt;/span&gt;        &lt;p style=&quot;white-space: pre-line;&quot;&gt;{{ message }}&lt;/p&gt;        &lt;br&gt;        &lt;textarea v-model=&apos;message&apos; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;    &lt;/div&gt;    &lt;script&gt;        var vm2 = new Vue({            el: &quot;#example2&quot;,            data: {                message: &apos;&apos;            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>文本区域插值(&lt;textarea&gt;&lt;/textarea&gt;)不会生效,请用v-model代替<br><br>3.复选框</p><pre><code>&lt;body&gt;    &lt;div id=&quot;example3&quot;&gt;        &lt;p&gt;单个复选框，绑定到布尔值:&lt;/p&gt;        &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&apos;checked&apos;&gt;        &lt;label for=&quot;checkbox&quot;&gt;{{ checked}}&lt;/label&gt;        &lt;p&gt;多个复选框，绑定到同一个数组:&lt;/p&gt;        &lt;input type=&quot;checkbox&quot; id=&quot;Jack&quot;  value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;        &lt;label for=&quot;Jack&quot;&gt;Jack&lt;/label&gt;        &lt;input type=&quot;checkbox&quot; id=&quot;John&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;        &lt;label for=&quot;John&quot;&gt;John&lt;/label&gt;        &lt;input type=&quot;checkbox&quot; id=&quot;Mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;        &lt;label for=&quot;Mike&quot;&gt;Mike&lt;/label&gt;        &lt;br&gt;        &lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm3 = new Vue({            el: &quot;#example3&quot;,            data: {                checked: false,                checkedNames: []            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>4.单选框</p><pre><code>&lt;body&gt;    &lt;div id=&quot;example4&quot;&gt;        &lt;p&gt;单选框&lt;/p&gt;        &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&apos;picked&apos;&gt;        &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;        &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&apos;picked&apos;&gt;        &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;        &lt;br&gt;        &lt;span&gt;Picked:{{ picked }}&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;         var vm4 = new Vue({            el: &quot;#example4&quot;,            data: {                picked: &apos;&apos;            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>5.选择框</p><pre><code>&lt;body&gt;    &lt;div id=&quot;example5&quot;&gt;        &lt;p&gt;单选&lt;/p&gt;        &lt;select v-model=&quot;selected&quot;&gt;            &lt;option value=&quot;&quot; disabled&gt;请选择&lt;/option&gt;            &lt;option &gt;A&lt;/option&gt;            &lt;option &gt;B&lt;/option&gt;            &lt;option &gt;C&lt;/option&gt;        &lt;/select&gt;        &lt;span&gt;Selected: {{selected}}&lt;/span&gt;        &lt;br&gt;        &lt;p&gt;多选时：绑定到一个数组&lt;/p&gt;        &lt;select v-model=&quot;selectedArray&quot; multiple style=&quot;width: 80px;&quot;&gt;           &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt;            &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt;           &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt;        &lt;/select&gt;        &lt;br&gt;        &lt;span&gt;Selected: {{selectedArray}}&lt;/span&gt;        &lt;br&gt;        &lt;p&gt;用 v-for 渲染的动态选项&lt;/p&gt;        &lt;select v-model=&quot;selectedDefalut&quot;&gt;            &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt;                {{ option.text}}            &lt;/option&gt;        &lt;/select&gt;        &lt;span&gt;Selected: {{selectedDefalut}}&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm5 = new Vue({            el: &quot;#example5&quot;,            data: {                selected: &apos;&apos;,                selectedArray: [],                selectedDefalut: &apos;A&apos;,                options: [                    {text: &apos;One&apos;, value: &quot;A&quot;},                    {text: &apos;Two&apos;, value: &apos;B&apos;},                    {text: &apos;Three&apos;, value: &apos;C&apos;}                ]            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>tips：</p><pre><code>单选时：    v-model表达式的初始值未能匹配任何选项，&lt;select&gt;元素将被渲染为“未选中”状态，推荐：提供一个值为空的禁用选项</code></pre><p>二、值绑定<br><br>使用v-bind实现把值绑定到Vue实例的一个动态属性上，并且这个值可以不是字符串。<br><br>1.复选框</p><pre><code>&lt;div id=&quot;example6&quot;&gt;    &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot;&gt;    &lt;label for=&quot;toggle&quot;&gt;{{toggle}}&lt;/label&gt;&lt;/div&gt;var vm6 = new Vue({    el: &quot;#example6&quot;,    data: {        toggle: &apos;yes&apos;    }});</code></pre><p>2.单选按钮</p><pre><code> &lt;div id=&quot;example6&quot;&gt;    &lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt;    &lt;label for=&quot;pick&quot;&gt;{{pick}}&lt;/label&gt;&lt;/div&gt;var vm6 = new Vue({    el: &quot;#example6&quot;,    data: {        a: &quot;hello&quot;,        pick: &apos;&apos;    }});</code></pre><p>3.选择框的选项</p><pre><code>  &lt;div id=&quot;example6&quot;&gt;    &lt;select v-model=&quot;selected&quot;&gt;        &lt;!-- 内联对象字面量 --&gt;        &lt;option v-bind:value=&quot;{number: 123}&quot;&gt;123&lt;/option&gt;    &lt;/select&gt;&lt;/div&gt; var vm6 = new Vue({    el: &quot;#example6&quot;,    data: {        selected: &apos;&apos;    }});</code></pre><p>三、修饰符<br><br>.lazy</p><pre><code>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。也可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步        </code></pre><p>.number</p><pre><code>想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符;</code></pre><p>.trim</p><pre><code>要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符;</code></pre><p>eg:</p><pre><code>&lt;body&gt;    &lt;div id=&quot;example7&quot;&gt;        &lt;!-- 在“change”时而非“input”时更新 --&gt;        &lt;input v-model.lazy=&quot;msg&quot; placeholder=&quot;使用 change 事件进行同步&quot;&gt;        &lt;br&gt;        &lt;input v-model.number=&quot;msg&quot; placeholder=&quot;输入值转为数值类型&quot;&gt;        &lt;br&gt;        &lt;input v-model.trim=&quot;msg&quot; placeholder=&quot;自动过滤收尾空白字符&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        var vm7 = new Vue({            el: &quot;#example7&quot;,            data: {                msg: &apos;Hello Vue&apos;            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>四、组件上使用v-model<br><br><a href="https://cn.vuejs.org/v2/guide/components.html#在组件上使用-v-model" target="_blank" rel="noopener">自定义组件</a><br><br>参考资料:<br><br>1.<a href="https://cn.vuejs.org/v2/guide/forms.html" target="_blank" rel="noopener">Vue-表单</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、基础用法&lt;br&gt;&lt;br&gt;使用 v-model 指令在表单 &amp;lt;input&amp;gt; 及 &amp;lt;textarea&amp;gt; 元素上创建双向数据绑定；&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
</feed>
