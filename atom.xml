<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tao的博客</title>
  <icon>https://www.gravatar.com/avatar/0ec302a3316b44d288c6f37788db9f6e</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tao1010.github.io/"/>
  <updated>2018-06-20T13:46:51.378Z</updated>
  <id>http://tao1010.github.io/</id>
  
  <author>
    <name>Tao</name>
    <email>dengtao_dev@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试</title>
    <link href="http://tao1010.github.io/2018/06/20/%E5%85%B6%E4%BB%96/%E6%B5%8B%E8%AF%95/"/>
    <id>http://tao1010.github.io/2018/06/20/其他/测试/</id>
    <published>2018-06-20T13:42:23.000Z</published>
    <updated>2018-06-20T13:46:51.378Z</updated>
    
    <content type="html"><![CDATA[<p>测试</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试&lt;/p&gt;
    
    </summary>
    
      <category term="测试" scheme="http://tao1010.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://tao1010.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架-组件</title>
    <link href="http://tao1010.github.io/2018/06/20/vue%E6%A1%86%E6%9E%B6/Vue%E6%A1%86%E6%9E%B6-%E7%BB%84%E4%BB%B6/"/>
    <id>http://tao1010.github.io/2018/06/20/vue框架/Vue框架-组件/</id>
    <published>2018-06-20T05:31:46.000Z</published>
    <updated>2018-06-20T13:23:58.430Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">Vue - 组件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;参考资料:&lt;br&gt;&lt;br&gt;1.&lt;a href=&quot;https://cn.vuejs.org/v2/guide/components.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue - 组件&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架-基础-表单</title>
    <link href="http://tao1010.github.io/2018/06/20/vue%E6%A1%86%E6%9E%B6/Vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-%E8%A1%A8%E5%8D%95/"/>
    <id>http://tao1010.github.io/2018/06/20/vue框架/Vue框架-基础-表单/</id>
    <published>2018-06-20T05:31:33.000Z</published>
    <updated>2018-06-20T13:23:58.430Z</updated>
    
    <content type="html"><![CDATA[<p>一、基础用法</p><a id="more"></a><p>1.文本</p><p>2.多行文本</p><p>3.复选框</p><p>4.单选框</p><p>5.选择框</p><p>二、值绑定</p><p>1.复选框</p><p>2.单选按钮</p><p>3.选择框的选项</p><p>三、修饰符</p><p>.lazy</p><p>.number</p><p>.trim</p><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org/v2/guide/forms.html" target="_blank" rel="noopener">Vue-表单</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、基础用法&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue框架-基础-事件处理</title>
    <link href="http://tao1010.github.io/2018/06/20/vue%E6%A1%86%E6%9E%B6/Vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://tao1010.github.io/2018/06/20/vue框架/Vue框架-基础-事件处理/</id>
    <published>2018-06-20T05:31:20.000Z</published>
    <updated>2018-06-20T13:23:58.430Z</updated>
    
    <content type="html"><![CDATA[<p>1.监听事件</p><a id="more"></a><p>v-on 可以接收JavaScript代码<br><br>指令监听DOM事件，并在触发时运行JavaScript：</p><pre><code>&lt;div id=&quot;app7&quot;&gt;    &lt;button v-on:click=&quot; counter += 1&quot;&gt;+ 1&lt;/button&gt;    &lt;p&gt;The button above has been clicked {{ counter}} times.&lt;/p&gt;&lt;/div&gt;var vm7 = new Vue({    el: &apos;#app7&apos;,    data: {        counter: 0    }});</code></pre><p>2.事件处理方法<br><br>v-on 接收需要调用的方法名称：</p><pre><code>&lt;div id=&quot;app8&quot;&gt;    &lt;button v-on:click=&apos;greet&apos;&gt;Greet&lt;/button&gt;&lt;/div&gt;var vm8 = new Vue({    el: &apos;#app8&apos;,    data: {        name: &apos;Vue.js&apos;    },    // 在 ‘method’ 对象中定义方法    methods: {        greet: function(event){            // ‘this’ 在方法里指向当前Vue实例            alert(&apos;Hello &apos; + this.name + &apos;!&apos;)            // &apos;event&apos; 是原生DOM事件            if(event){                alert(event.target.tagName)            }        }    }});</code></pre><p>用于处理逻辑复杂场景！<br><br>3.内联处理器中的方法<br><br>v-on 可以在内联的JavaScript中调用方法：</p><pre><code>&lt;div id=&quot;app9&quot;&gt;    &lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;Say Hi&lt;/button&gt;    &lt;button v-on:click=&quot;say(&apos;what&apos;)&quot;&gt;Say what&lt;/button&gt;    &lt;button v-on:click=&quot;warn(&apos;Form cannot be submitted yet.&apos;,$event)&quot;&gt;Submit&lt;/button&gt;&lt;/div&gt;var vm9 = new Vue({    el: &quot;#app9&quot;,    methods: {        say: function(message){            alert(message)        },        warn: function(message,event){            if(event){                event.preventDefault()            }            alert(message)        }    }});</code></pre><p>v-on 有时需要在内联语句处理器中访问原始的DOM事件，可以用特殊变量$event 把它传入方法：</p><pre><code>eg:上述‘Submit’ 按钮</code></pre><p>4.事件修饰符<br><br>常用的需求处理方法：</p><pre><code>event.preventDefault()event.stopPropagation()修饰符是由点开头的指令后缀来表示：    .stop    .prevent    .capture    .self    .once    .passive - 尤其能够提升移动端的性能eg:    &lt;!-- 阻止单击事件继续传播 --&gt;    &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;    &lt;!-- 提交事件不再重载页面 --&gt;    &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;    &lt;!-- 修饰符可以串联 --&gt;    &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;    &lt;!-- 只有修饰符 --&gt;    &lt;form v-on:submit.prevent&gt;&lt;/form&gt;    &lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;    &lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;    &lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;    &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;    &lt;!-- 即事件不是从内部元素触发的 --&gt;    &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;    &lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;    &lt;!-- 而不会等待 `onScroll` 完成  --&gt;    &lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;    &lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</code></pre><p>修饰符可用串联，顺序不同结果不同：</p><pre><code>v-on:click.prevent.self 会阻止所有的点击v-on:click.self.prevent 只会阻止对元素自身的点击</code></pre><p>tips:</p><pre><code>不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。.passive 会告诉浏览器你不想阻止事件的默认行为;</code></pre><p>5.按键修饰符<br><br>Vue允许为 v-on 在监听键盘事件时添加按键修饰符：</p><pre><code>eg：    &lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;    &lt;input v-on:keyup.13=&quot;submit&quot;&gt;全部按键别名：    .enter    .tab    .esc    .space    .up    .down    .left    .right</code></pre><p>可以通过全局 config.keyCodes 对象自定义按键修饰符别名：</p><pre><code>// 可以使用 `v-on:keyup.f1`Vue.config.keyCode.f1 = 12</code></pre><p>自动匹配按键修饰符</p><pre><code>可直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符：    &lt;input @keyup.page-down=&quot;onPageDown&quot;&gt;    解析：处理函数仅在 $event.key === &apos;PageDown&apos; 时被调用</code></pre><p>有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，它们的内置别名应该是首选。<br><br>6.系统修饰键<br><br>实现仅在按下相应按键时才触发鼠标或键盘事件的监听器：</p><pre><code>.ctrl.alt.shift.meta.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件 （v2.5.0 add）鼠标按钮修饰键 v2.2.0 add    .left    .right    .middle这些修饰符会限制处理函数仅响应特定的鼠标按钮</code></pre><p>tips：    </p><pre><code>不同系统键盘的按键的区别；修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17；</code></pre><p>7.在HTML中监听事件<br><br>v-on的优势：</p><pre><code>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法；无须在 JavaScript 里手动绑定事件，ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试；当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。无须担心如何自己清理它们;</code></pre><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org" target="_blank" rel="noopener">Vue.js中文官网</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.监听事件&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Python-linux基础-用户权限</title>
    <link href="http://tao1010.github.io/2018/06/19/Python/Python-linux%E5%9F%BA%E7%A1%80-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90/"/>
    <id>http://tao1010.github.io/2018/06/19/Python/Python-linux基础-用户权限/</id>
    <published>2018-06-19T07:22:11.000Z</published>
    <updated>2018-06-20T13:23:58.368Z</updated>
    
    <content type="html"><![CDATA[<p>一、SSH高级<br></p><a id="more"></a><p>二、用户权限</p><p>三、组管理</p><p>四、用户管理</p><p>五、系统信息</p><p>六、其他命令</p><p>七、打包压缩</p><p>八、软件安装</p><p>参考资料:<br>1.<a href="https://pan.baidu.com/s/1o3eZ1nJTKDi4PRZpeUizgw" target="_blank" rel="noopener">黑马视频</a>  密码:m8tu<br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、SSH高级&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="linux" scheme="http://tao1010.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python-linux基础-linux命令</title>
    <link href="http://tao1010.github.io/2018/06/19/Python/Python-linux%E5%9F%BA%E7%A1%80-linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://tao1010.github.io/2018/06/19/Python/Python-linux基础-linux命令/</id>
    <published>2018-06-19T02:01:42.000Z</published>
    <updated>2018-06-20T13:23:58.362Z</updated>
    
    <content type="html"><![CDATA[<p>一、Linux命令        </p><a id="more"></a><p>1.常用的Linux命令的基本使用        </p><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>ls</td><td>list</td><td>查看当前文件夹下的内容</td></tr><tr><td>2</td><td>pwd</td><td>print wrok directory</td><td>查看当前所在文件夹</td></tr><tr><td>3</td><td>cd [目录名]</td><td>change directory</td><td>切换文件夹</td></tr><tr><td>4</td><td>touch [文件名]</td><td>touch</td><td>如果文件不存在，新建文件</td></tr><tr><td>5</td><td>mkdir [目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>6</td><td>rm [文件名]</td><td>remove</td><td>删除指定的文件名</td></tr><tr><td>7</td><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><p>2.终端窗口字体</p><pre><code>command + shift + = 放大字体command + - 减小字体</code></pre><p>3.终端命令格式<br>command [-options] [parameter]        </p><pre><code>command:命令名，相应功能的英文单词或单词的缩写；[-options]:选项，可用来对命令进行控制，也可以省略；[parameter]:传给命令的参数，可以时零个，一个或者多个；[]: 代表可选eg:     ls     pwd    clear     cd /Users/jingxiankeji_tao/Desktop/前端    touch 新的文件.txt    mkdir 新的文件夹    rm 要删除的文件.txt</code></pre><p>注意：命令和参数之间必须要有空格，选项和参数之间必须要有空格.<br>4.查询帮助命令信息<br>command –help        </p><pre><code>显示command命令的帮助信息</code></pre><p>man command</p><pre><code>查阅command命令的使用手册;q - 退出,空格键 - 显示手册的下一屏,b - 回滚一屏,f - 前滚一屏 ;man是manual的缩写;</code></pre><p>二、文件和目录命令<br>1.Linux下文件和目录的特点<br>ls命令扩展：</p><pre><code>以.为起始的文件，默认为隐藏文件,需要用 -a参数能显示所有内容. 代表当前目录.. 代表上一级目录</code></pre><table><thead><tr><th>命令</th><th>描述</th><th>eg</th></tr></thead><tbody><tr><td>ls -a</td><td>显示指定目录下所有子目录与文件，包括隐藏文件</td><td></td></tr><tr><td>ls -l</td><td>以列表方式显示文件的详细信息</td><td></td></tr><tr><td>ls -l -h</td><td>配合ls -l以人性化的方式显示文件大小(B,K,M表示大小)</td><td></td></tr><tr><td>ls通配符的使用</td><td></td></tr><tr><td>*</td><td>代表任意个数个字符</td><td>ls 1<em> 或ls -</em>1.txt或ls - <em>3 </em></td></tr><tr><td>？</td><td>代表任意一个字符</td><td>ls 1?3.txt</td></tr><tr><td>[]</td><td>表示可以匹配字符组中的任意一个</td><td></td></tr><tr><td>[abc]</td><td>匹配a,b,c中任意一个</td><td>ls -[12345]23.txt</td></tr><tr><td>[a-f]</td><td>匹配a到f中的任意一个</td><td>ls -[1-5]23.txt</td></tr></tbody></table><p>多个命令可以连在一起使用，无先后顺序:</p><pre><code>eg:ls -lh    ls -lha / ls -lah</code></pre><p>2.自动补全</p><pre><code>输入文件名/文件夹名/路径名的头几个字母，按 tab 键自动补全；按2下 tab 键 可以筛选出相同起始字母的内容；</code></pre><p>3.历史命令切换</p><pre><code>上/下 键control + c 退出选择</code></pre><p>4.命令扩展</p><table><thead><tr><th>命令</th><th>描述</th><th>eg</th></tr></thead><tbody><tr><td>ls</td><td>list，查看目录内容</td><td></td></tr><tr><td>cd</td><td>切换目录 change directory</td><td></td></tr><tr><td>touch</td><td>创建文件 - 文件不存在；修改文件最后日期-文件已存在</td><td>touch 123.txt</td></tr><tr><td>rm</td><td>删除 直接从磁盘删除，不可恢复</td><td>rm 123.txt</td></tr><tr><td>rm -f</td><td>强制删除，忽略不存在的文件，无需提示</td><td>rm 123.txt</td></tr><tr><td>rm -r</td><td>递归的删除目录下的内容，删除文件夹时必须加此参数</td><td>rm -r 新建文件夹</td></tr><tr><td>rm -r</td><td>不能在根目录做此操作</td><td>rm -r * 删除当前目录的所有目录和文件</td></tr><tr><td>mkdir</td><td>创建一个新目录(文件夹) 不能与当前目录中已存在的目录同名</td><td>mkdir 新建文件夹</td></tr><tr><td>mkdir -p</td><td>可以递归创建目录 不能与当前目录中已存在的目录同名</td><td>mkdir -p 父文件夹/子文件夹/A/B/</td></tr><tr><td>tree [目录名]</td><td>tree</td><td>以树状图列出文件目录结构</td></tr><tr><td>cp 源文件 目标文件</td><td>拷贝 copy</td><td></td></tr><tr><td>mv</td><td>移动</td><td></td></tr><tr><td>cat</td><td></td><td></td></tr><tr><td>more</td><td></td><td></td></tr><tr><td>grep</td><td></td><td></td></tr><tr><td>echo</td><td></td></tr></tbody></table><p>5.切换目录 cd (change directory)</p><pre><code>Linux所有的目录和文件名大小写敏感cd  切换到当前用户的主目录(home/用户目录)cd ~ 切换当当前用户主目录(home/用户目录)cd . 保持当前目录不变cd .. 切换到上级目录cd - 可以在最近两次工作目录之间来回切换相对路径: 最前面不是/或者～，表示 相对当前目录 所在的目录位置绝对路径:最前面是/或者～，表示从 根目录/家目录 开始的具体目录位置</code></pre><p>6.拷贝和移动文件</p><table><thead><tr><th>命令格式</th><th>英文</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>tree [目录名]</td><td>tree</td><td>以树状图列出文件目录结构</td><td>tree -d 只显示目录</td></tr><tr><td>cp 源文件 目标文件</td><td>copy</td><td>复制文件或者目录</td><td>cp ~/Documents/readme.txt ./readme/txt</td></tr><tr><td>mv 源文件 目标文件</td><td>move</td><td>移动文件或者目录/文件或者目录重命名</td></tr></tbody></table><p>eg:</p><pre><code>cp 1.png 2.png    //复制源文件1.png 到当前目录下，重命名为2.pngcp 1.png 新建文件夹/2.png //复制源文件1.png 到当前目录下的新建文件夹下，重命名为2.pngcp -i 1.png 1.png //覆盖文件前操作提示cp -r test1 test2 //复制目录test1 到当前目录下 重命名为test2mv 新建文件夹/1.png 3.png //移动 新建文件夹 下的 1.png文件 到当前目录下 重命名为3.pngmv -i 1.png test/2.png // 覆盖文件操作提示 移动1.png 到test文件夹下 重命名为2.png</code></pre><p>tips：<font color="red">在终端中 对文件的操作不能回撤</font><br><br>7.查看文件内容</p><table><thead><tr><th>命令格式</th><th>英文</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>cat 文件名</td><td>concatenate</td><td>查看文件内容、创建文件、文件合并、追加文件内容等功能，适合内容较少的情况</td><td></td></tr><tr><td>more 文件名</td><td>more</td><td>分屏显示文件内容,每次只显示一页内容，适合内容较多的情况</td><td></td></tr><tr><td>grep 文件名</td><td>grep</td><td>搜索文本文件内容</td></tr></tbody></table><p>more的操作：</p><pre><code>空格键 显示手册页的下一屏enter 一次滚动手册页的一行b 回滚一屏f 前滚一屏q 退出/word 搜索word字符串</code></pre><p>grep模式查找:</p><pre><code>模式查找又称为正则表达式查找^a 行首 搜索以a开头的行a$ 行为 搜索以a结束的行</code></pre><p>eg:</p><pre><code>cat -b test.txt //  显示test.txt 文件内容 对非空输出行编号cat -n test.txt //  显示test.txt 文件内容 对输出的所有行编号more test.txt // 显示test.txt 文件内容grep sa test.txt //搜索test.txt 文件中 包含sa文本grep -n sa test.txt // 显示行号  搜索test.txt 文件中 包含sa文本grep -v sa test.txt //显示不包含匹配文本 搜索test.txt 文件中 包含sa文本grep -vn sa test.txt //显示不包含sa文本的 行号grep -i sa test.txt //忽略大小写grep ^6 test.txt //搜索以 6 开始的行grep n$ test.txt //搜索以 n 结束的行</code></pre><p>三、其他命令<br><br>1.echo</p><pre><code>格式：echo 文本内容作用：echo会在终端显示参数指定的文字，通常会和重定向联合使用</code></pre><p>2.重定向 &gt; 和 &gt;&gt;</p><pre><code>linux 允许将命令执行结果 重定向到一个文件将本应显示在终端上的内容 输出/追加 到指定文件中&gt; 表示输出 会覆盖文件原有内容&gt;&gt; 表示追加 会将内容追加到已有文件的末尾</code></pre><p>3.管道 |</p><pre><code>Linux允许将一个命令的输出 可以通过管道 作为另一个命令的输入</code></pre><p>4.eg:</p><pre><code>echo Hello &gt; 11.txt // 在当前目录下 输出 Hello 到11.txt 中 (没有11.txt 则新建11.txt文件)echo Hello Python &gt;&gt; 11.txt // 追加 文本 Hello Python 到11.txt文件中的末伟</code></pre><p>四、远程管理命令<br><br>1.关机和重启<br></p><pre><code>安全关闭或重新启动系统格式:shutdown 选项 时间 eg:    shutdown //默认表示1分钟后关闭电脑    shutdown -r now //现在重新启动电脑    shutdown 20:25 //系统在今天20:25关机    shutdown -c 取消关机或重启命令    shutdown +10 10分钟之后关机tips: 远程维护服务器最好不要关闭系统，而应该重新启动系统</code></pre><p>2.查看或配置网卡信息<br><br>命令格式：</p><pre><code>ifconfig  #configure a networking interface 查看/配置计算机当前的网卡配置信息ping ip地址  #ping 检查到目标IP地址的连接是否正常 ip地址也可以用域名代替(ping www.baidu.com)control + c 结束ping</code></pre><p>网卡</p><pre><code>一个专门负责网络通讯的硬件设备；IP地址是设置在网卡上的地址信息；eg: 电脑&lt;==&gt;电话 网卡&lt;==&gt;SIM卡 IP地址&lt;==&gt;电话号码tips:一台计算机中可能会有多个物理网卡和多个虚拟网卡，在linux中的物理网卡的名字通常以ensXX表示</code></pre><p>iP地址</p><pre><code>每台联网的电脑上都有一个IP地址，保证电脑间正常通讯的重要设备；每台电脑的IP地址不能相同，否则会出现IP地址冲突，并且没有办法正常通讯</code></pre><p>eg</p><pre><code>ifconfig #查看网卡配置信息ifconfig | grep inet #查看网卡对应的IP地址 （通过管道输入 过滤查找inet关键字信息）ping IP地址 #检测到目标主机的连接是否正常ping 192.168.122.xx</code></pre><p><img src="ping.png" alt="ping"></p><pre><code>解析:发送56字节的数据到 IP(192.168.122.xx),在time时间内收到对应的64字节的数据回执，时间越短网速越快.</code></pre><font color="red">3.远程登录和复制文件</font><br><br>命令格式:<br><br>    ssh 用户名@ip   #secure shell 关机/重新启动<br>    scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径 #secure copy 远程复制文件<br><font color="red">ssh(secure shell)基础 - 重点</font><pre><code>SSH客户端是一种使用Secure Shell(SSH)协议连接到远程计算机的软件程序；SSH是目前比较可靠，专为远程登录会话和其他网络服务提供安全性的协议；SSH传输的数据可以经过 压缩 ，从而加快传输速度    利用SSH协议可以有效防止远程管理过程中的信息泄露；    通过SSH协议可以对所有传输数据进行 加密 ，防止DNS欺骗和IP欺骗；域名    用一串用点分割的名字组成 eg：www.baidu.com    是IP地址的别名，方便用户记忆端口号    IP地址：通过 IP地址 找到网络上的计算机    端口号：通过 端口号 可以找到计算机上运行的应用程序        SSH服务器的默认端口号是 22，如果是默认端口号，在连接的时候可以忽略    常见服务器端口号列表：        SSH服务器     默认端口号22        Web服务器     默认端口号80        HTTPS         默认端口号443        FTP服务器     默认端口号21</code></pre><p>SSH客户端的简单使用</p><pre><code>命令:ssh [-p port] user@remote解析：    user 是在远程机器上的用户名，如果不指定的话默认当前用户    remote 是远程机器的地址，可以是IP/域名。或者是别名    port 是SSH Server监听的端口，如果不指定，默认22tips:     exit #退出当前用户    ssh终端命令只能在Linux或UNIX系统下使用    windows系统中，安装Putty或是XShell 客户端软件    在工作中，SSH服务器的端口号可能不是22，此时需要使用-p选项，指定正确的端口号，否则无法正常连接服务器sudo #超级用户的权限    </code></pre><font color="red">scp - 掌握 </font><pre><code>scp就是secure copy 是一个在Linux下用来进行 远程拷贝文件 的命令它的地址格式与ssh基本相同，在指定端口时用的是大写的 -P，而不是小写的-r 选项表示传送文件夹-P 若远程SSH 服务器的端口不是22，需要使用大写字母-P选项指定端口eg:    #把本地当前目录下的 01.py文件 复制到远程 家目录下的 Desktop/01.py    scp -P port 01.py user@remote: Desktop/01.py    #把远程 家目录下的Desktop/01.py 文件 复制到 本地当前目录下的 01.py    scp -P port user@remote:Desktop/01.py 01.py    #把当前目录下的demo文件夹 复制到远程 家目录下的 Desktop    scp -r demo user@remote:Desktop    #把远程家目录下的 Desktop 复制到 当前目录下的demo文件夹     scp -r user@remote:Desktop demo</code></pre><p>4.FileZilla在Windows下文件传输</p><pre><code>使用Filezilla 通过FTP进行文件传输端口号 21</code></pre><p>参考资料:<br>1.<a href="https://pan.baidu.com/s/1o3eZ1nJTKDi4PRZpeUizgw" target="_blank" rel="noopener">黑马视频</a>  密码:m8tu<br><br>2.<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">Putty</a><br><br>3.<a href="http://www.xshellcn.com/" target="_blank" rel="noopener">XShell</a><br><br>4.<a href="https://filezilla-project.org/download.php?type=client" target="_blank" rel="noopener">FileZilla在Windows下文件传输</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、Linux命令        &lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://tao1010.github.io/categories/Python/"/>
    
    
      <category term="linux" scheme="http://tao1010.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>vue框架-基础-列表渲染</title>
    <link href="http://tao1010.github.io/2018/06/15/vue%E6%A1%86%E6%9E%B6/vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <id>http://tao1010.github.io/2018/06/15/vue框架/vue框架-基础-列表渲染/</id>
    <published>2018-06-15T06:47:39.000Z</published>
    <updated>2018-06-20T13:23:58.431Z</updated>
    
    <content type="html"><![CDATA[<p>1.用v-for把一个数组对应为一组元素</p><a id="more"></a><pre><code>用 v-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名;eg1:    HTML:     &lt;div&gt;        &lt;ul id=&quot;app3&quot;&gt;            &lt;li v-for=&apos;item in items&apos;&gt;                {{ item.message }}            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    JS:    var vm3 = new Vue({        el: &apos;#app3&apos;,        data: {            items: [                {message: &apos;牛奶&apos;},                {message: &apos;橙汁&apos;},                {message: &apos;雪碧&apos;}            ]        }    });    控制台:    vm3.items.push({message: &apos;可乐&apos;}) 在 v-for 块中，拥有对父作用域属性的完全访问权限。v-for 还支持一个可选的第二个参数为当前项的索引：eg2：    HTML:    &lt;div&gt;        &lt;ul id=&quot;app4&quot;&gt;            &lt;li v-for=&quot;(item,index) in items&quot;&gt;                {{ parentMessage }} - {{ index }} - {{ item.message }}            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    JS:    var vm4 = new Vue({        el: &apos;#app4&apos;,        data: {            parentMessage: &apos;Parent&apos;,            items: [                {message: &apos;牛奶&apos;},                {message: &apos;橙汁&apos;},                {message: &apos;雪碧&apos;}            ]        }    });也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：eg3:    &lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;</code></pre><p>2.一个对象的v-for<br></p><!-- more --><pre><code>可以用 v-for 通过一个对象的属性来迭代:eg1:    HTML:    &lt;div&gt;        &lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;            &lt;li v-for=&quot;value in object&quot;&gt;                {{ value }}            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    JS:    var vm5 = new Vue({        el: &apos;#v-for-object&apos;,        data: {            object: {                firstName: &apos;John&apos;,                lastName: &apos;Doe&apos;,                age: 30            }        }    });可以提供第二个参数的键名：eg2:    &lt;div v-for=&quot;(value, key) in object&quot;&gt;      {{ key }}: {{ value }}    &lt;/div&gt;第三个参数为索引：eg3:    &lt;div v-for=&quot;(value, key, index) in object&quot;&gt;      {{ index }}. {{ key }}: {{ value }}    &lt;/div&gt;</code></pre><p>在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的.<br><br>3.key</p><p>4.数组更新检测<br><br>变异方法</p><pre><code>push()pop()shift()unshift()splice()sort()reverse()在控制台输入上述变异方法：eg:example1.items.push({ message: &apos;Baz&apos; })</code></pre><p>替换数组</p><pre><code>filter()concat()slice()不会改变原始数组，但会返回一个新数组，可以用新数组替换原来的旧数组,Vue 不会 丢弃之前的DOM，重新渲染整个列表，Vue会使用智能的、启发式的方法。eg:    example1.items = example1.items.filter(function (item) {          return item.message.match(/Foo/)    })</code></pre><p>tips:</p><pre><code>由于JavaScript的限制，Vue不能检测一下变动的数组：1.当利用索引直接设置一个项时；eg:    #控制台通过索引直接修改数组中元素的值，浏览器上不响应    vm.items[0] = &apos;0&apos;解决方案:#方法一：属性vm.items.splice(indexOfItem,1,newvalue)eg:vm.items.splice(0,1,&apos;0&apos;)#方法二：全局方法Vue.set(vm.items,indexOfItem,newvalue)eg:Vue.set(vm.items,1,&apos;2&apos;)2.当修改数组的长度时；解决方法：vm.items.splice(newLength)eg:vm.items.splice(4)</code></pre><p>5.对象更新检测<br><br>由于JavaScript的限制，Vue不能检测对象属性的添加或删除：</p><pre><code>解决方法：#方法一：全局方法Vue.set(object,key,value) eg:#向嵌套对象添加响应式属性    var vm = Vue({        data:{            userInfo:{                name: &apos;John&apos;            }        }    })    #添加age属性    Vue.set(vm.userInfo,&apos;age&apos;,20)方法二：实例方法    vm.$set(vm.userInfo,&apos;age&apos;,20)</code></pre><p>为已有的对象赋予多个新的属性</p><pre><code>Object.assgin() 或者 _.ectend()eg：vm.userInfo = Object.assgin({},vm.userInfo,{    age: 20,    sex: &apos;M&apos;})</code></pre><p>6.显示过滤/排序结果<br><br>显示一个数组的过滤或排序副本，不实际改变或重置原始数据:</p><pre><code>&lt;li v-for=&quot;n in evenNumbers&quot;&gt;{{n}}&lt;/li&gt;计算属性可用：var vm = new Vue({    data:{        numbers:[1,2,3,4]    },    computed:{        evenNumbers: function(){            return: this.numbers.filter(function (number){                return number % 2 ===0            })        }    }}) 计算属性不可以，使用method方法：var vm = new Vue({    data:{        numbers:[1,2,3,4]    },    method:{        even: function(numbers){            return: numbers.filter(function (number){                return number % 2 ===0            })        }    }})</code></pre><p>7.一段取值范围的v-for</p><pre><code>v-for 可以取整数，它将重复多次模版</code></pre><p>8.v-for on a &lt;template&gt;</p><pre><code>利用带有v-for的&lt;template&gt;渲染多个元素&lt;ul&gt;  &lt;template v-for=&quot;item in items&quot;&gt;    &lt;li&gt;{{ item.msg }}&lt;/li&gt;    &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt;  &lt;/template&gt;&lt;/ul&gt;</code></pre><p>9.v-for 和 v-if</p><pre><code>当v-for和v-if处于同一节点：    v-for优先级高于v-if，v-if将分别重复运行于每个v-for循环中使用场景：想为仅有的一些项 渲染节点eg:    &lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;          {{ todo }}    &lt;/li&gt;如果想有条件的跳过循环的执行，可以将v-if置于外层元素(或者&lt;template&gt;)上eg:    &lt;ul v-if=&quot;todos.length&quot;&gt;      &lt;li v-for=&quot;todo in todos&quot;&gt;        {{ todo }}      &lt;/li&gt;    &lt;/ul&gt;    &lt;p v-else&gt;No todos left!&lt;/p&gt;</code></pre><p>10.一个组件的v-for</p><p>跳过组件…</p><p>七、事件处理<br><br>八、表单输入绑定<br><br>参考资料:<br><br>1.<a href="https://cn.vuejs.org" target="_blank" rel="noopener">Vue.js中文官网</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.用v-for把一个数组对应为一组元素&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue框架-基础-条件渲染</title>
    <link href="http://tao1010.github.io/2018/06/15/vue%E6%A1%86%E6%9E%B6/vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
    <id>http://tao1010.github.io/2018/06/15/vue框架/vue框架-基础-条件渲染/</id>
    <published>2018-06-15T06:45:59.000Z</published>
    <updated>2018-06-20T13:23:58.432Z</updated>
    
    <content type="html"><![CDATA[<p>1.v-if</p><a id="more"></a><pre><code>1.v-if 是一个指令，必须将它添加到一个元素上eg1：    &lt;h1 v-if=&quot;isOK&quot;&gt;YES&lt;/h1&gt;    &lt;h1 v-else&gt;NO&lt;/h1&gt;2.在&lt;template&gt;元素上使用v-if条件渲染分组eg2：     &lt;div id=&quot;app1&quot;&gt;        &lt;template v-if=&apos;isOK&apos;&gt;            &lt;h1&gt;菜鸟教程-Vue&lt;/h1&gt;            &lt;p&gt;条件分组渲染1&lt;/p&gt;            &lt;p&gt;条件分组渲染2&lt;/p&gt;        &lt;/template&gt;    &lt;/div&gt;3.v-else可以使用 v-else 指令来表示 v-if 的“else 块”;必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别;eg3:    &lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;      Now you see me    &lt;/div&gt;    &lt;div v-else&gt;      Now you don&apos;t    &lt;/div&gt;4.v-else-if类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后;5.用key管理可复用的元素eg：     HTML      &lt;div id=&quot;app2&quot;&gt;        &lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;            &lt;label&gt;UserName&lt;/label&gt;            &lt;input placeholder=&quot;请输入您的姓名&quot; key=&quot;username-input&quot;&gt;        &lt;/template&gt;        &lt;template v-else&gt;            &lt;label&gt;Email&lt;/label&gt;            &lt;input placeholder=&quot;请输入您的邮箱&quot; key=&quot;email-input&quot;&gt;        &lt;/template&gt;        &lt;div&gt;            &lt;button v-on:click=&apos;changeType&apos;&gt;切换&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;        JS      var vm2 = new Vue({        el: &apos;#app2&apos;,        data: {            loginType: &apos;username&apos;        },        methods: {            changeType: function(){                if(this.loginType === &apos;username&apos;){                    this.loginType = &apos;hello&apos;                }else{                    this.loginType = &apos;username&apos;                }            }        }    });    </code></pre><p>2.v-show</p><pre><code>用于根据条件展示元素的选项是 v-show 指令;不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display;v-show 不支持 &lt;template&gt; 元素，也不支持 v-else;eg:    &lt;h2 v-show=&apos;isOK&apos;&gt;Hello Vue!&lt;/h2&gt;</code></pre><p>3.v-if VS v-show</p><pre><code>v-if    是“真正”的条件渲染 - 会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建;    是惰性的 - 如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块;v-show    不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换;v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销;需要频繁地切换，使用v-show较好;运行时条件很少改变，使用v-if较好;</code></pre><p>4.v-if 与v-for一起使用</p><pre><code>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级;</code></pre><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org" target="_blank" rel="noopener">Vue.js中文官网</a><br><br>2.<a href="https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if" target="_blank" rel="noopener">列表渲染指南</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.v-if&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue框架-基础-Class和Style绑定</title>
    <link href="http://tao1010.github.io/2018/06/15/vue%E6%A1%86%E6%9E%B6/vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-Class%E5%92%8CStyle%E7%BB%91%E5%AE%9A/"/>
    <id>http://tao1010.github.io/2018/06/15/vue框架/vue框架-基础-Class和Style绑定/</id>
    <published>2018-06-15T06:44:41.000Z</published>
    <updated>2018-06-20T13:23:58.430Z</updated>
    
    <content type="html"><![CDATA[<pre><code>操作元素的 class 列表和内联样式是数据绑定的一个常见需求;在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组;</code></pre><p>1.绑定HTML Class</p><a id="more"></a><pre><code>对象语法    1.传给 v-bind:class 一个对象，以动态地切换 class        &lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;    2.可以在对象中传入更多属性来动态切换多个 class    3.v-bind:class 指令也可以与普通的 class 属性共存        &lt;div class=&quot;static&quot;             v-bind:class=&quot;{ active: isActive, &apos;text-danger&apos;: hasError }&quot;&gt;        &lt;/div&gt;数组语法    可以把一个数组传给 v-bind:class，以应用一个 class 列表：        &lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;        data: {          activeClass: &apos;active&apos;,          errorClass: &apos;text-danger&apos;        }    渲染为：        &lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;在组件上    先学习Vue组件...</code></pre><p>2.绑定内联样式</p><pre><code>对象语法    v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。    CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名        &lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &apos;px&apos; }&quot;&gt;&lt;/div&gt;         data: {             activeColor: &apos;red&apos;,             fonSize: 30         }    直接绑定样式对象(是的模版更清晰):        &lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;        data: {            styleObject: {                color: &apos;red&apos;,                fontSize: &apos;13px&apos;            }        }数组语法    v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：        &lt;div v-bind: style=&quot;[baseStyle, overridingStyles]&quot;&gt;&lt;/div&gt;自动添加前缀    当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀多重值(2.3.0+)    可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值:        &lt;div :style=&quot;{ display: [&apos;-webkit-box&apos;, &apos;-ms-flexbox&apos;, &apos;flex&apos;] }&quot;&gt;&lt;/div&gt;        解析:            这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex</code></pre><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org" target="_blank" rel="noopener">Vue.js中文官网</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;操作元素的 class 列表和内联样式是数据绑定的一个常见需求;
在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.绑定HTML Class&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue框架-基础-计算属性和侦听器</title>
    <link href="http://tao1010.github.io/2018/06/15/vue%E6%A1%86%E6%9E%B6/vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/"/>
    <id>http://tao1010.github.io/2018/06/15/vue框架/vue框架-基础-计算属性和侦听器/</id>
    <published>2018-06-15T06:42:49.000Z</published>
    <updated>2018-06-20T13:23:58.432Z</updated>
    
    <content type="html"><![CDATA[<pre><code>对于任何复杂逻辑，都应当使用计算属性;</code></pre><p>1.基础例子</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message&#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#example'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                message: <span class="string">'Hello'</span></span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            computed: &#123;</span></span><br><span class="line"><span class="javascript">                 <span class="comment">// 计算属性的 getter</span></span></span><br><span class="line"><span class="javascript">                reversedMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// `this` 指向 vm 实例</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>解析:    声明了一个计算属性 reversedMessage。提供的函数将用作属性 vm.reversedMessage 的 getter 函数;    打开浏览器的控制台，自行修改例子中的 vm。vm.reversedMessage 的值始终取决于 vm.message 的值;</code></pre><p>2.计算属性缓存 VS 方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#example'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                message: <span class="string">'Hello'</span></span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            computed: &#123;</span></span><br><span class="line"><span class="javascript">                 <span class="comment">// 计算属性的 getter</span></span></span><br><span class="line"><span class="javascript">                reversedMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// `this` 指向 vm 实例</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//方法</span></span></span><br><span class="line"><span class="javascript">                reversedMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>解析：    计算属性和方法得到的结果完全相同;    计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值,意味着：        只要message没有发生改变，多次访问reversedMessage 计算属性会立即返回之前的计算结果，不必在此执行函数;    每当触发重新渲染时,调用的方法总会再次执行函数;</code></pre><p>使用场景：</p><pre><code>缓存场景:    当一个性能开销较大的计算属性A，需要遍历一个巨大的数组并做大量计算.如果有其他的计算属性依赖于A,若无缓存，将多次执行A的getter。若不希望有缓存，请用方法替代。    </code></pre><p>3.计算属性 VS 侦听属性<br></p><pre><code>&lt;div id=&quot;demo&quot;&gt;{{ fullName }}&lt;/div&gt;</code></pre><p>侦听属性:</p><pre><code>var vm = new Vue({  el: &apos;#demo&apos;,  data: {    firstName: &apos;Foo&apos;,    lastName: &apos;Bar&apos;,    fullName: &apos;Foo Bar&apos;  },  watch: {    firstName: function (val) {      this.fullName = val + &apos; &apos; + this.lastName    },    lastName: function (val) {      this.fullName = this.firstName + &apos; &apos; + val    }  }})</code></pre><p>计算属性:</p><pre><code>var vm = new Vue({  el: &apos;#demo&apos;,  data: {    firstName: &apos;Foo&apos;,    lastName: &apos;Bar&apos;  },  computed: {    fullName: function () {      return this.firstName + &apos; &apos; + this.lastName    }  }})</code></pre><p>4.计算属性的setter</p><pre><code>计算属性默认只有getter,但在需要时可提供settereg：    HTML    &lt;div id=&quot;demo&quot;&gt;{{ fullName}}&lt;/div&gt;    JS    &lt;script&gt;        var vm = new Vue({            el: &apos;#demo&apos;,            data: {                firstName: &apos;Foo&apos;,                lastName: &apos;Bar&apos;,            },            computed: {                fullName: {                    get: function(){                        return this.firstName + &apos; &apos; + this.lastName                    },                    set: function(){                        var names = newValue.split(&apos; &apos;)                        this.firstName = names[0]                        this.lastName = names[names.length - 1]                    }                }            }        })    &lt;/script&gt;</code></pre><p>5.侦听器</p><pre><code>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的</code></pre><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org" target="_blank" rel="noopener">Vue.js中文官网</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;对于任何复杂逻辑，都应当使用计算属性;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.基础例子&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue框架-基础-模版语法</title>
    <link href="http://tao1010.github.io/2018/06/14/vue%E6%A1%86%E6%9E%B6/vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-%E6%A8%A1%E7%89%88%E8%AF%AD%E6%B3%95/"/>
    <id>http://tao1010.github.io/2018/06/14/vue框架/vue框架-基础-模版语法/</id>
    <published>2018-06-14T06:39:08.000Z</published>
    <updated>2018-06-20T13:23:58.432Z</updated>
    
    <content type="html"><![CDATA[<p>1.插值<br></p><a id="more"></a><p>文本<br></p><pre><code>数据绑定最常见的形式:使用 &quot;Mustache&quot; 语法 - 双大括号{{}}的文本插值eg1: - 实时更新    &lt;span&gt;Message: {{ msg }}&lt;/span&gt;解析1：    只要绑定的数据对象 msg属性发生改变，插值处的内容都会更新;eg2: - 一次更新    &lt;span v-once&gt;这个将不会改变: {{ msg }}&lt;/span&gt;解析2:    通过使用指令v-once，执行一次性插值，当数据改变时，插值处的内容不会更新;</code></pre><p>原始HTML<br></p><pre><code>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：</code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123; once &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"getMessage"</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches:&#123;&#123;rawHtml&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive:<span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">'rawHtml'</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                message: <span class="string">'Hello Vue!'</span>,</span></span><br><span class="line"><span class="javascript">                once: <span class="string">'一次性插值'</span>,</span></span><br><span class="line"><span class="xml">                rawHtml: "<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">'color:red'</span>&gt;</span>This should be red."</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="javascript">            created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'created'</span>)</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="javascript">                getMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.message = <span class="string">'haha'</span></span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><font color="red">站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值</font><br><br>特性<br></p><pre><code>Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令：    &lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;布尔值特性:    &lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;解析：    如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的 &lt;button&gt; 元素中</code></pre><p>使用JavaScript表达式<br></p><pre><code>每个绑定都只能包含单个表达式;模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date ;不应该在模板表达式中试图访问用户定义的全局变量。</code></pre><p>2.指令<br></p><pre><code>指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM.</code></pre><p>参数</p><pre><code>一些指令能够接收一个“参数”，在指令名称之后以冒号表示:参数是：href    &lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;参数是：监听的事件名    &lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;eg：&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;p&gt;{{ok? 'Yes': 'NO'}}&lt;/p&gt;        &lt;p v-if=&apos;seen&apos;&gt;现在看见你了&lt;/p&gt;        &lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt;        &lt;a v-on:click=&apos;doSomething&apos;&gt;doSomething&lt;/a&gt;    &lt;/div&gt;    &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;    &lt;script&gt;        var vm = new Vue({            el: &apos;#app&apos;,            data: {                url: &apos;https://www.baidu.com&apos;,                seen: true,                ok: true,            },            created: function(){                console.log(&apos;created&apos;)            },            methods: {                getMessage: function (){                    this.message = &apos;haha&apos;                },                doSomething: function (){                    this.url = &apos;https://cn.vuejs.org&apos;                }            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>修饰符</p><pre><code>修饰符 (Modifiers) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。    &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</code></pre><p>3.缩写<br></p><pre><code>Vue.js为最常用的指令提供简写：    v-bind    完整：&lt;a v-bind:href=&apos;url&apos;&gt;...&lt;/a&gt;    简写：&lt;a :href=&apos;url&apos;&gt;...&lt;/a&gt;    v-on    完整：&lt;a v-on:click=&apos;doSomething&apos;&gt;...&lt;/a&gt;    简写：&lt;a @click=&apos;doSomething&apos;&gt;...&lt;/a&gt;</code></pre><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org" target="_blank" rel="noopener">Vue.js中文官网</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.插值&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue框架-基础-实例</title>
    <link href="http://tao1010.github.io/2018/06/14/vue%E6%A1%86%E6%9E%B6/vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-%E5%AE%9E%E4%BE%8B/"/>
    <id>http://tao1010.github.io/2018/06/14/vue框架/vue框架-基础-实例/</id>
    <published>2018-06-14T06:21:57.000Z</published>
    <updated>2018-06-20T13:23:58.431Z</updated>
    
    <content type="html"><![CDATA[<p>1.创建Vue实例<br></p><a id="more"></a>    <pre><code>每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的;    var vm = new Vue({        //选项    })文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例;一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成;    根实例    └─ TodoList       ├─ TodoItem       │  ├─ DeleteTodoButton       │  └─ EditTodoButton       └─ TodoListFooter          ├─ ClearTodosButton          └─ TodoListStatistics所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外);</code></pre><p>2.数据和方法<br></p><pre><code>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值;只有当实例被创建时 data 中存在的属性才是响应式的;如果在晚些时候需要一个属性，但是一开始它为空或不存在，那么仅需要设置一些初始值;</code></pre><p>例外:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"foo = 'baz'"</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">            foo: <span class="string">'bar'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.freeze(obj)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">            data: obj</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>解析：    使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化;</code></pre><p>Vue实例还暴露了实例属性和方法</p><pre><code>它们前缀 $ ，以便与用户定义的属性区分开;eg:     var data = {a: 1}    var vm = new Vue({        el: &apos;#example&apos;,        data: data    })    vm.$data === data //true    vm.$el === document.getElementById(&apos;example&apos;)//ture    vm.$watch(&apos;a&apos;, function(newValue,oldValue) {        //这个回调将在&apos;vm.a&apos;改变后调用    })</code></pre><p>3.实例生命周期钩子<br>    </p><pre><code>每个Vue实例在被创建时都要经过一系列初始化过程：    设置数据监听    编译模版    将实例挂载到DOM    数据变化时更新DOM    ...等生命周期钩子:    用户在不同阶段添加自己代码的时机.Vue实例生命周期钩子：    created - 创建    mounted - 挂载到DOM    updated - 更新DOM    destroyed - 销毁</code></pre><p>eg:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"getMessage"</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                message: <span class="string">'Hello Vue!'</span></span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="javascript">            created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'created'</span>)</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="javascript">                getMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.message = <span class="string">'haha'</span></span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>tips:</p><pre><code>不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(&apos;a&apos;, newValue =&gt; this.myMethod())原因：    箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误</code></pre><p>4.生命周期图示<br><br><img src="lifecycle.png" alt="lifecycle"><br></p><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org" target="_blank" rel="noopener">Vue.js中文官网</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.创建Vue实例&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>搭建本地SVN仓库</title>
    <link href="http://tao1010.github.io/2018/06/13/%E5%85%B6%E4%BB%96/%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0SVN%E4%BB%93%E5%BA%93/"/>
    <id>http://tao1010.github.io/2018/06/13/其他/搭建本地SVN仓库/</id>
    <published>2018-06-13T09:10:15.000Z</published>
    <updated>2018-06-20T13:23:58.441Z</updated>
    
    <content type="html"><![CDATA[<p>1.Mac自带SVN</p><pre><code>查看版本信息:    svnserve --version</code></pre><p>2.创建代码仓库</p><pre><code>sudo mkdir -p ~/DeskTop/SVNStore</code></pre><p>3.初始化代码仓库</p><pre><code>sudo svnadmin create ~/Desktop/SVNStore </code></pre><p><img src="svnstore.png" alt="svnstore"><br></p><p>4.配置SVN权限</p><pre><code>修改SVNStore --&gt; conf 文件夹下内容:svnserve.conf 配置用户权限    anon-access = read    auth-access = write    password-db = passwd    authz-db = authz    解析：        代表匿名访问的时候是只读的，若改为anon-access = none代表禁止匿名访问，需要帐号密码才能访问        删除前面的注视，不要留空格passwd 配置账号信息    [users]    deng = 123456    deng1 = 123456    解析：        在[users]下添加用户(eg:用户名=密码)authz 配置权限    [groups]    iosdev = deng,deng1    ...    [/]    @iosdev = rw    解析：        配置名为 iosdev 的用户组,组下用户为 deng，deng1(如果多个用户，用‘,’分割)        在最下面添加 [/] 表示授权目录路径访问权限, @ioddev = rw 表示给 iosdev 组 读写权限(r - 读,w - 写,rw - 读写)        如果只允许用户访问项目下Demo文件目录,则:            [/Demo]            @iosdev = rw        @iosdev 表示授权给iosdev组,不使用 @ 则表示授权给用户</code></pre><p>5.启动svn服务</p><pre><code>svnserve -d -r ~/Desktop/SVNStore 解析:    回直接启动配置好的 SVNStore SVN服务器 默认使用80端口    如不使用默认的端口:        svnserve -d -r ~/Desktop/SVNStore --listen-port 8080</code></pre><p>6.使用Cornerstone等工具连接SVN<br><br><img src="dengSVN.jpg" alt="dengSVN"><br></p><pre><code>在Cornerstone中的Server： 输入为本地电脑IP地址</code></pre><p>7.添加内容，提交<br><br><img src="commiterror.png" alt="commiterror"><br></p><pre><code>1.终端: sudo chmod -R a+w ~/Desktop/SVNStore2.终端: 输入电脑管理员密码    即可成功提交!</code></pre><p>参考资料:<br><br>1.<a href="https://www.jianshu.com/p/0c06f80a2561" target="_blank" rel="noopener">Mac上搭建本地SVN仓库</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Mac自带SVN&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查看版本信息:
    svnserve --version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.创建代码仓库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mkdir -p ~/DeskTop/SVNStore
&lt;/code&gt;
      
    
    </summary>
    
      <category term="其他" scheme="http://tao1010.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="SVN" scheme="http://tao1010.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>MBP上安装Ubuntu</title>
    <link href="http://tao1010.github.io/2018/06/13/%E5%85%B6%E4%BB%96/MBP%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu/"/>
    <id>http://tao1010.github.io/2018/06/13/其他/MBP上安装Ubuntu/</id>
    <published>2018-06-13T07:10:43.000Z</published>
    <updated>2018-06-20T13:23:58.433Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：<br><br>1.<a href="https://www.cnblogs.com/diligenceday/p/6103530.html" target="_blank" rel="noopener">Mac上安装ubuntu</a><br><br>2.<a href="https://blog.csdn.net/babytang008/article/details/70879634" target="_blank" rel="noopener">Mac OS + Ubuntu + Windows</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考资料：&lt;br&gt;&lt;br&gt;1.&lt;a href=&quot;https://www.cnblogs.com/diligenceday/p/6103530.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mac上安装ubuntu&lt;/a&gt;&lt;br&gt;&lt;br&gt;2.&lt;a 
      
    
    </summary>
    
      <category term="其他" scheme="http://tao1010.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="系统" scheme="http://tao1010.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>vue框架-基础-介绍</title>
    <link href="http://tao1010.github.io/2018/06/13/vue%E6%A1%86%E6%9E%B6/vue%E6%A1%86%E6%9E%B6-%E5%9F%BA%E7%A1%80-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://tao1010.github.io/2018/06/13/vue框架/vue框架-基础-介绍/</id>
    <published>2018-06-13T03:22:51.000Z</published>
    <updated>2018-06-20T13:23:58.431Z</updated>
    
    <content type="html"><![CDATA[<p>1.声明式渲染<br></p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.文本插值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.绑定元素特性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-bind:title</span>=<span class="string">'message'</span>&gt;</span>鼠标悬停几秒钟查看此处动态绑定的提示信息!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                message: <span class="string">'Hello World Vue!'</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app-2'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                message : <span class="string">'页面加载于'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString()</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>解析：1.    Vue做了大量的背后工作;    数据和DOM已经建立了关联;    所以东西都是响应式的;2.    v-bind 特性被称为指令；        实例中 v-bind:title=&apos;message&apos;  表示：将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致    指令带有前缀 v-，表示它们是Vue提供的新特性；    浏览器的 JavaScript 控制台，输入 app2.message = &apos;新消息&apos;，鼠标放到文本上 就会看到这个绑定了 title 特性的 HTML 已经进行了更新</code></pre><p>2.条件与循环<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.条件与循环 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">'seen'</span>&gt;</span>现在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-4"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span>&#123;&#123; todo.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app3 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app-3'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                seen: <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app4 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app-4'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="undefined">                todos: [</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">text</span>: <span class="string">'学习JavaScript'</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">text</span>: <span class="string">'学习Vue'</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">text</span>: <span class="string">'整个牛项目'</span>&#125;</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>解析:    控制台输入 app3.seen = false，显示的消息消失;    控制台里，输入 app4.todos.push({ text: &apos;新项目&apos; })，列表最后添加了一个新项目；v-for 指令可以绑定数组的数据来渲染一个项目列表;可以把数据绑定到 DOM 文本或特性，还可以绑定到 DOM 结构;Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用过渡效果</code></pre><p>3.处理用户输入<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.处理用户输入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-5"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"reverseMessage"</span>&gt;</span>逆转消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-6"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">'message'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app5 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app-5'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                message: <span class="string">'Hello Vue.js!'</span></span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="javascript">                reverseMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app6 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app-6'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="javascript">                message: <span class="string">'Hello Vue!'</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>解析:    可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法;    在 reverseMessage 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可;    Vue 还提供了 v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定</code></pre><p>4.组件化应用构建<br></p><pre><code>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用;几乎任意类型的应用界面都可以抽象为一个组件树;在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例;</code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.组件 - 4.2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app-7"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            现在我们为每个 todo-item 提供 todo 对象</span></span><br><span class="line"><span class="comment">            todo 对象是变量，即其内容可以是动态的。</span></span><br><span class="line"><span class="comment">            我们也需要为每个组件提供一个“key”，稍后再</span></span><br><span class="line"><span class="comment">            作详细解释。</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">todo-item</span>  <span class="attr">v-for</span>=<span class="string">'item in groceryList'</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">v-bind:todo</span>=<span class="string">'item'</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">v-bind:key</span>=<span class="string">'item.id'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 组件化构建 - 4.1注册</span></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'todo-item'</span>, &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// todo-item 组件现在接受一个</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// "prop"，类似于一个自定义特性。</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 这个 prop 名为 todo。</span></span></span><br><span class="line"><span class="javascript">            props: [<span class="string">'todo'</span>],</span></span><br><span class="line"><span class="xml">            template: '<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; todo.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//4.3</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app7 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app-7'</span>,</span></span><br><span class="line"><span class="undefined">            data: &#123;</span></span><br><span class="line"><span class="undefined">                groceryList: [</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">id</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">'蔬菜'</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'奶酪'</span>&#125;,</span></span><br><span class="line"><span class="javascript">                    &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'随便其它什么人吃的东西'</span>&#125;</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>解析:    子单元通过 prop 接口与父单元进行了良好的解耦;    可以进一步改进 &lt;todo-item&gt; 组件，提供更为复杂的模板和逻辑，而不会影响到父单元;</code></pre><p>在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理;</p><p>5.自定义组件和自定义元素的关系:</p><pre><code>Vue组件类似于自定义元素,它是Web组件规范的一部分；关键差别:    Web组件规范处于草案阶段，未被所有浏览器原生实现；    Vue组件不需要任何polfill，所有浏览器表现一致；    Vue组件可包装于原生自定义元素内；    Vue组件提供纯自定义元素所不具备的功能:        跨组件数据流、自定义事件通信、构建工具集成.            </code></pre><p>参考资料:<br><br>1.<a href="https://cn.vuejs.org" target="_blank" rel="noopener">Vue.js中文官网</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.声明式渲染&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="vue" scheme="http://tao1010.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向-砸壳</title>
    <link href="http://tao1010.github.io/2018/06/13/iOS/iOS%E9%80%86%E5%90%91/iOS%E9%80%86%E5%90%91-%E7%A0%B8%E5%A3%B3/"/>
    <id>http://tao1010.github.io/2018/06/13/iOS/iOS逆向/iOS逆向-砸壳/</id>
    <published>2018-06-13T01:06:09.000Z</published>
    <updated>2018-06-20T13:23:58.422Z</updated>
    
    <content type="html"><![CDATA[<p>前提：</p><pre><code>iOS设备(iPhone 或者 iPad 均可)已越狱</code></pre><p>一、工具和软件<br>1.<a href="https://pro.25pp.com/pp_mac_ios" target="_blank" rel="noopener">PP助手Mac版</a><br><br>2.iOS微信App(正式) 6.6.7 - Mac PP助手下载<br><br>3.<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpcrypted - 砸壳</a><br><br>4.<a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">class-dump - 导出头文件</a><br><br>5.<a href="http://www.iosopendev.com" target="_blank" rel="noopener">iOSOpenDev1.6-2 - 替换方法</a><br><br>6.<a href="https://github.com/Tyilo/insert_dylib" target="_blank" rel="noopener">insert_dylib - 动态注入方法</a><br><br>   <a href="https://github.com/KJCracks/yololib" target="_blank" rel="noopener">yololib - 动态注入</a><br><br>7.<a href="https://sourceforge.net/projects/machoview/" target="_blank" rel="noopener">MachOView - 查看注入是否成功</a><br><br>8.<a href="https://github.com/DanTheMan827/ios-app-signer" target="_blank" rel="noopener">iOS App Signer - 签名工具</a></p><p>二、资源和环境<br>1.macOS Hign Sierra 10.13.4<br><br>2.iOS11.2.1 和 iOS11.3.1 <br><br>3.Xcode9.3.1<br><br>三、操作步骤<br><br>1.class-dump导出头文件</p><pre><code>class-dump -H XXX/Payload/WeChat.app -o XXX/WeChatHeaders </code></pre><p>2.查看 WeChatHeaders 文件夹 </p><pre><code>若文件夹中只有 CDStructures.h 文件,且文件中什么也没有,则需要砸壳;若文件夹中包含11695个文件，则完成头文件的导出步骤;</code></pre><p>3.未导出文件继续执行下述操作。<a href="https://tao1010.github.io/2018/06/08/iOS/iOS逆向/iOS逆向-实战-微信红包和步数/">已导出文件-传送门</a><br><br>4.在已越狱的iOS设备上安装软件</p><pre><code>通过Cydia安装    OpenSSH - 实现远程登录    Cycript - 在命令行下实现与应用的交互PP助手</code></pre><p>5.确保iOS设备和Mac处于同一局域网中，在Mac终端输入命令：</p><pre><code>ssh root@192.168.1.121 远程登录已越狱的iOS设备;    默认密码: alpine    iOS设备局域网IP地址:192.168.1.121</code></pre><p>6.在越狱的iOS设备上运行微信App后，Mac终端输入命令：</p><pre><code>ps -e | grep WeChat解析:    此命令用于查找WeChat可执行文件的路径;记录此可执行文件的路径A</code></pre><p>7.通过Cycipt查找WeChat的Document路径，Mac终端输入命令:</p><pre><code>cycript -p WeChat解析：    此命令用于进入cycript命令状态</code></pre><p>8.在cycript命令状态下，输入命令:</p><pre><code>NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)[0]解析:    获取WeChat的Document路径记录此结果后的路径B</code></pre><p>9.将砸壳工具dumpdecrypted 拷贝到WeChat的Document目录下用于砸壳</p><pre><code>将命令切回Mac OS X输入: scp dumpdecrypted.dylib root@192.168.1.121:路径B(Document路径)</code></pre><p>10.重新远程登录到iPhone，使用dumpdecrypted.dylib砸壳，具体用法：</p><pre><code>DYLD_INSERT_LIBRARIES=/路径B(Documents路径)/dumpdecrypted.dylib 路径A(可执行文件路径)</code></pre><p>11.出现下图表示砸壳成功<br><br><img src="complete.png" alt="complete"><br><br>在当前路径下生成 WeChat.decrypted 文件<br><br><img src="success.png" alt="success"><br><br>12.将iOS设备上生成的 WeChat.decrypted 文件拷贝到Mac上</p><pre><code>scp WeChat.decrypted mac登录用户名@192.168.1.121:XXX/Desktop/解析:    jingxiankeji_tao - mac登录用户名     存放将要拷贝的 WeChat.decrypted 文件路径 - XXX/Desktop/</code></pre><p>13.检查 WeChat.decrypted 文件 是否砸壳成功<br><br><img src="check.png" alt="check"><br>        </p><pre><code>第一个cryptid 0表示armv7架构已成功，第二个cryptid 1表示arm64未成功理论上只要把最老的架构解密就可以了，因为新的cpu会兼容老的架构；所以这里arm64未成功不影响    </code></pre><p>14.再次远程连接iOS设备，拷贝WeChat.app待用</p><pre><code>ssh root@192.168.1.121 远程登录已越狱的iOS设备;    默认密码: alpine    iOS设备局域网IP地址:192.168.1.121scp -r 路径A(可执行文件路径的上一级 WeChat.app)@192.168.1.60:XXX/Desktop/解析：    路径A - iOS设备上存放 WeChat.app 的路径    XXX/Desktop/ - 存放将要拷贝 WeChat.app 的路径</code></pre><p>15.砸壳完成,<a href="https://tao1010.github.io/2018/06/08/iOS/iOS逆向/iOS逆向-实战-微信红包和步数/">导出 .h 文件-传送门</a><br></p><p>参考资料：<br>1.<a href="https://www.jianshu.com/p/7c0c2bcbbaf2" target="_blank" rel="noopener">非越狱微信步数和红包</a>    <br><br>2.<a href="https://www.jianshu.com/p/a4373b5feca0" target="_blank" rel="noopener">dumpdecrypted - 砸壳</a><br><br>3.<a href="http://bbs.iosre.com" target="_blank" rel="noopener">iOSRE逆向</a><br><br>4.<a href="https://www.jianshu.com/p/ad578bef4b76" target="_blank" rel="noopener">iOS微信自动抢红包-入门教程</a><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前提：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iOS设备(iPhone 或者 iPad 均可)已越狱
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一、工具和软件&lt;br&gt;1.&lt;a href=&quot;https://pro.25pp.com/pp_mac_ios&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="iOS" scheme="http://tao1010.github.io/categories/iOS/"/>
    
    
      <category term="逆向" scheme="http://tao1010.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>编译和打包Web</title>
    <link href="http://tao1010.github.io/2018/06/12/Web/%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%93%E5%8C%85Web/"/>
    <id>http://tao1010.github.io/2018/06/12/Web/编译和打包Web/</id>
    <published>2018-06-12T00:55:09.000Z</published>
    <updated>2018-06-20T13:23:58.373Z</updated>
    
    <content type="html"><![CDATA[<p>一、Node<br></p><a id="more"></a><p>1.安装<a href="https://nodejs.org" target="_blank" rel="noopener">Node</a><br></p><pre><code>Node和npm会 默认安装在/usr/local/bin目录下</code></pre><p>2.命令终端退出<br></p><pre><code>1.control + d - 当命令出现时使用(ctrl+d)2.control + c - 当命令在运行时，只有光标闪烁时使用(ctrl+c)</code></pre><p>二、步骤(编译和打包)<br><br><img src="build.jpg" alt="build"><br><br>工程快捷命令:</p><pre><code>查看目录文件中 package.json 文件中 key: &apos;scripts&apos; 所对应的值： &quot;scripts&quot;: {    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,    &quot;start&quot;: &quot;npm run dev&quot;,    &quot;build&quot;: &quot;node build/build.js&quot;,    &quot;http&quot;: &quot;node ./service/http/http.js&quot;  }  npm run start &lt;==&gt; npm run dev  npm run build &lt;===&gt; node build/build.js  npm run http &lt;===&gt; node ./service/http/http.js</code></pre><p>1.安装node<br></p><pre><code>查看node版本： node --version    查看npm(node的包管理器)版本: npm -v</code></pre><p>2.配置npm相关文件文件</p><pre><code>npm install</code></pre><p>3.cd到项目目录下：</p><pre><code>cd xxx/xxx/xxx/2.0</code></pre><p>4.在生产环境运行项目</p><pre><code>npm run start命令结束：    ...    DONE  Compiled successfully in 18125ms     Your application is running here: http://localhost:8080</code></pre><p>5.在浏览器中输入步骤4完成时提供的IP：</p><pre><code>http://localhost:8080</code></pre><p>6.编译</p><pre><code>npm run build命令结束:    Build complete.   Tip: built files are meant to be served over an HTTP server.   Opening index.html over file:// won&apos;t work.    在工程目录下生成dist文件夹</code></pre><p>7.将dist文件夹中的内容拷贝到发布的路径中即可发布。</p><p>8.开辟本地服务器运行项目</p><pre><code>npm run http命令结束：    start http://localhost:9090    在浏览器中输入IP即可查看项目</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、Node&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://tao1010.github.io/categories/Web/"/>
    
    
      <category term="web-build" scheme="http://tao1010.github.io/tags/web-build/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序-组件-其他</title>
    <link href="http://tao1010.github.io/2018/06/11/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BB%84%E4%BB%B6-%E5%85%B6%E4%BB%96/"/>
    <id>http://tao1010.github.io/2018/06/11/小程序/微信小程序-组件-其他/</id>
    <published>2018-06-11T05:51:45.000Z</published>
    <updated>2018-06-20T13:23:58.457Z</updated>
    
    <content type="html"><![CDATA[<p>一、navigator - 导航<br><br>1.属性<br></p><pre><code>open-type - 跳转方式 默认navigate    有效值:    navigate    对应 wx.navigateTo 或wx.navigateToMiniProgram 的功能        redirect    对应 wx.redirectTo 的功能    switchTab    对应 wx.switchTab 的功能        reLaunch    对应 wx.reLaunch 的功能        navigateBack    对应 wx.navigateBack 的功能target 在哪个目标上发生跳转，默认当前小程序url 当前小程序内的跳转链接delta 当 open-type 为 &apos;navigateBack&apos; 时有效，表示回退的层数app-id 当target=&quot;miniProgram&quot;时有效，要打开的小程序 appIdpath 当target=&quot;miniProgram&quot;时有效，打开的页面路径，如果为空则打开首页extra-data     当target=&quot;miniProgram&quot;时有效，需要传递给目标小程序的数据，目标小程序可在 App.onLaunch()，App.onShow() 中获取到这份数据version 当target=&quot;miniProgram&quot;时有效，要打开的小程序版本，有效值 develop（开发版），trial（体验版），release（正式版），仅在当前小程序为开发版或体验版时此参数有效；如果当前小程序是正式版，则打开的小程序必定是正式版 默认releasehover-class 指定点击时的样式类，当hover-class=&quot;none&quot;时，没有点击态效果hover-stop-propagation 指定是否阻止本节点的祖先节点出现点击态hover-start-time 按住后多久出现点击态，单位毫秒 默认50hover-stay-time 手指松开后点击态保留时间，单位毫秒 默认50</code></pre><p>2.navigator-hover 默认为 {background-color: rgba(0, 0, 0, 0.1); opacity: 0.7;}, <navigator> 的子节点背景色应为透明色</navigator></p><p>二、canvas - 画布<br><br>1.属性<br></p><pre><code>canvas-id canvas组件的唯一标志符disable-scroll 当在 canvas 中移动时且有绑定手势事件时，禁止屏幕滚动以及下拉刷新 默认 falsebindtouchstart 手指触摸动作开始bindtouchmove    手指触摸后移动bindtouchend 手指触摸动作结束bindtouchcancel    手指触摸动作被打断 如来电提醒、弹框等bindlongtap    手指长按500ms之后触发，触发了长按事件后进行移动不会触发屏幕的滚动binderror 当发生错误时触发error事件，detail={errMsg:&apos;...&apos;}</code></pre><p>2.tips:</p><pre><code>canvas 标签默认300px、高度225px;同一页面中的canvas-id不可重复，如果使用一个已用的canvas-id，该canvas标签对应的画布将被隐藏并不再正常工作。</code></pre><p>三、开发能力<br><br>1.open-data - 微信开发数据</p><pre><code>type    开放数据类型    groupname 拉取群名称    userNickName    userAvatarUrl    userGender    userCity    userProvince    userCountry    userLanguageopen-gid 当 type=&quot;groupName&quot; 时生效, 群idlang 当 type=&quot;user*&quot; 时生效，以哪种语言展示 userInfo，有效值有：en, zh_CN, zh_TW 默认en        </code></pre><p>2.web-view - 用了承载网页的容器，自动铺满小程序页面<br></p><pre><code>src webView指向的网页，需小程序管理后台配置域名白名单bindmessage 网页向小程序 postMessage 时，会在特定时机（小程序后退、组件销毁、分享）触发并收到消息。e.detail = { data }网页内iframe的域名也需要配置到域名白名单。开发者工具上，可以在 &lt;web-view/&gt; 组件上通过右键 - 调试，打开 &lt;web-view/&gt; 组件的调试。每个页面只能有一个&lt;web-view/&gt;，&lt;web-view/&gt;会自动铺满整个页面，并覆盖其他组件。&lt;web-view/&gt;网页与小程序之间不支持除JSSDK提供的接口之外的通信。在iOS中，若存在JSSDK接口调用无响应的情况，可在&lt;web-view/&gt;的src后面加个#wechat_redirect解决。</code></pre><p>3.ad - 广告</p><pre><code>目前暂时以邀请制开放申请，请留意后续模板消息的通知;</code></pre><p>参考资料:<br>1.<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" target="_blank" rel="noopener">导航组件</a><br><br>2.<a href="https://www.w3cschool.cn/weixinapp/" target="_blank" rel="noopener">W3C-小程序开发文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、navigator - 导航&lt;br&gt;&lt;br&gt;1.属性&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open-type - 跳转方式 默认navigate
    有效值:
    navigate    对应 wx.navigateTo 或wx.navigateToMiniP
      
    
    </summary>
    
      <category term="小程序" scheme="http://tao1010.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://tao1010.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向-实战-微信红包和步数</title>
    <link href="http://tao1010.github.io/2018/06/08/iOS/iOS%E9%80%86%E5%90%91/iOS%E9%80%86%E5%90%91-%E5%AE%9E%E6%88%98-%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E5%92%8C%E6%AD%A5%E6%95%B0/"/>
    <id>http://tao1010.github.io/2018/06/08/iOS/iOS逆向/iOS逆向-实战-微信红包和步数/</id>
    <published>2018-06-08T05:31:12.000Z</published>
    <updated>2018-06-20T13:23:58.407Z</updated>
    
    <content type="html"><![CDATA[<p>一、工具和软件<br>1.<a href="https://pro.25pp.com/pp_mac_ios" target="_blank" rel="noopener">PP助手Mac版</a><br><br>2.iOS微信App(越狱) 6.6.7 - Mac PP助手下载<br><br>3.<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpcrypted - 砸壳</a><br><br>4.<a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">class-dump - 导出头文件</a><br><br>5.<a href="http://www.iosopendev.com" target="_blank" rel="noopener">iOSOpenDev1.6-2 - 替换方法</a><br><br>6.<a href="https://github.com/Tyilo/insert_dylib" target="_blank" rel="noopener">insert_dylib - 动态注入方法</a><br><br>   <a href="https://github.com/KJCracks/yololib" target="_blank" rel="noopener">yololib - 动态注入</a><br><br>7.<a href="https://sourceforge.net/projects/machoview/" target="_blank" rel="noopener">MachOView - 查看注入是否成功</a><br><br>8.<a href="https://github.com/DanTheMan827/ios-app-signer" target="_blank" rel="noopener">iOS App Signer - 签名工具</a></p><p>二、资源和环境<br>1.macOS Hign Sierra 10.13.4<br><br>2.iOS11.2.1 和 iOS11.3.1 <br><br>3.Xcode9.3.1<br></p><p>三、操作步骤<br>1.安装Mac PP助手;        <br><br>2.在PP助手中下载越狱的微信app(在未连接手机的状态下在);  <br></p><pre><code>如果是从appstore上下载微信app，由于此时的app是经过加密的,则需要先进行砸壳;如果是越狱的微信App,则不需要砸壳;</code></pre><p>3.拷贝一份微信App,修改其后缀名：.ipa–&gt;.zip,解压ZIP文件;<br><br>4.安装class-dump工具;<br></p><pre><code>在命令终端输入:class-dump 可查看class-dump软件的使用命令;</code></pre><p>5.使用class-dump指令获取微信头文件;<br></p><pre><code>命令终端输入:    class-dump -H xxxx(上述步骤3中解压的WeChat文件)/Payload/WeChat.app -o xxx(新建的文件夹-用于导出微信头文件)/WeChatHeaders    eg:    class-dump -H /Users/jingxiankeji_tao/Desktop/WeChat/Payload/WeChat.app -o /Users/jingxiankeji_tao/Desktop/WeChatHeaders </code></pre><p>6.检查头文件是否导出正确:</p><pre><code>查看导出的头文件夹:    若CDStructures.h中无数据：        1.还需要砸壳，工具有：AppCrackr、Clutch、dumpcrypted等，推荐dumpcrypted；        2.当砸壳完毕后，使用 class-dump 仍然只导出 CDStructures.h一个文件，则可能架构选择错误，armv7对应的是iPhone5及以下的设备，arm64则是5s及以上的设备，所以微信也包含两个架构，armv7和arm64,使用如下命令:            class-dump --arch armv7 xxxx/Payload/WeChat.app -H -o xxx/WeChatHeaders    若存在11695个文件，则完成头文件的导出步骤;</code></pre><p>7.定位相关的文件(步数或红包)<br><br>四、微信步数<br><br>1.定位于步数相关的文件<br></p><pre><code>搜索头文件夹下的包含‘step’的文件    WCDeviceStepObject.h</code></pre><p>2.分析文件方法:用Xcode打开WCDeviceStepObject.h文件</p><pre><code>#import &quot;MMObject.h&quot;@class NSMutableArray;@interface WCDeviceStepObject : MMObject{    ...    unsigned int m7StepCount;    unsigned int hkStepCount;    ...}...@property(nonatomic) unsigned int hkStepCount; // @synthesize hkStepCount;@property(nonatomic) unsigned int m7StepCount; // @synthesize m7StepCount;...@end分析：    此处的两个属性get方法：判断HealthKit是否可用，并去获取其中数据;    替换两个get方法即可修改微信运动的步数;</code></pre><p>3.使用工具iOSOpenDev替换方法</p><p><img src="iosopendev.png" alt="iosopendev"><br><br><img src="fixstep1.png" alt="fixstep1"><br></p><pre><code>1.利用iOSOpenDev创建hook模版    打开Xcode，进入创建一个新项目的菜单中，选择iOS--&gt;iOSOpenDev --&gt; CaptainHookTweak2.在代码中修改上述的两个get方法，返回想要的数值    在创建的项目XXX.mm文件中，具体修改如下:    @class WCDeviceStepObject;    CHDeclareClass(WCDeviceStepObject); // declare class    CHOptimizedMethod(0, self, unsigned long, WCDeviceStepObject, m7StepCount)    {        return 20151207;    }    CHOptimizedMethod(0, self, unsigned long, WCDeviceStepObject, hkStepCount)    {        return 20151207;    }    CHConstructor // code block that runs immediately upon load    {        @autoreleasepool        {            CHLoadLateClass(WCDeviceStepObject);            CHHook(0, WCDeviceStepObject, m7StepCount); // register hook            CHHook(0, WCDeviceStepObject, hkStepCount); // register hook        }}</code></pre><p>4.编译Xcode创建的项目ModifyStepCount<br><br><img src="dylib.png" alt="dylib"><br></p><pre><code>build xcode 生成 .dylib    </code></pre><p>5.用<a href="https://github.com/Tyilo/insert_dylib" target="_blank" rel="noopener">insert_dylib工具</a> 动态库的地址注入Mach-O</p><pre><code>insert_dylib使用方法：    用xcode打开下载的insert_dylib项目，并编译，通过Xcode中的Products下 选中insert_dylib 右键 show in Finder      将 insert_dylib 脚本拷贝到 /usr/local/bin 目录中        不放到此目录中需要使用./insert_dylib，        放在目录中后只需要使用insert_dylib步骤：    1.先将动态库ModifyStepCount.dylib 复制到 xx/Playload/WeChat.app 中;    2.cd 到需要注入的包中：        eg: cd xxx/xxx/Desktop/WeChat/Payload/WeChat.app/    3.命令:        insert_dylib @executable_path/ModifyStepCount.dylib WeChat    4.会生成 WeChat_patched 二进制文件        Binary is a fat binary with 2 archs.        LC_CODE_SIGNATURE load command found. Remove it? [y/n] n        LC_CODE_SIGNATURE load command found. Remove it? [y/n] n</code></pre><p>6.用<a href="https://sourceforge.net/projects/machoview/" target="_blank" rel="noopener">MachOView 工具</a> 查看新的动态库是否已经被注入了</p><pre><code>File --&gt; Open --&gt; xxx/WeChat/Payload/WeChat.app/Wechat_patchedFat Binary --&gt; Executable --&gt; Load Commands --&gt; LC_LOAD_DYLIB(ModifyStepCount.dylib)</code></pre><p>7.修改 WeChat_patched –&gt;WeChat 替换原来的文件，然后和ModifyStepCount.dylib 动态库一起放入WeChat.app中</p><pre><code>在菜单栏上 File--&gt;Open--&gt;xxx/Payload/WeChat.app/WeChat</code></pre><p>8.用<a href="https://github.com/DanTheMan827/ios-app-signer" target="_blank" rel="noopener">iOS App Signer - 工具</a>重签名并打包</p><pre><code>用xcode打开 iOS App Signer，选择证书和签名    可以新创建一个 个人账号生成证书 的 项目，用此证书重新签名在iOS App Singer 上执行相关操作后生成一个IPA包，安装在手机上即可。</code></pre><p>五、微信防撤回<br></p><pre><code>#pragma mark - 微信防撤回CHOptimizedMethod(1, self, void, CMessageMgr, onRevokeMsg, id, value1) {}#pragma mark - 微信步数CHDeclareClass(WCDeviceStepObject); // declare classCHOptimizedMethod(0, self, unsigned long, WCDeviceStepObject, m7StepCount){    return 151207;}CHOptimizedMethod(0, self, unsigned long, WCDeviceStepObject, hkStepCount){    return 151207;}__attribute__((constructor)) static void entry(){    //加载CMessageMgr类    CHLoadLateClass(CMessageMgr);    //hook AsyncOnAddMsg:MsgWrap:方法    CHClassHook(2, CMessageMgr, AsyncOnAddMsg, MsgWrap);    // 微信步数  CHLoadLateClass(WCDeviceStepObject);    CHHook(0, WCDeviceStepObject, m7StepCount);    CHHook(0, WCDeviceStepObject, hkStepCount);    // 消息防撤回    CHHook(1, CMessageMgr, onRevokeMsg);}</code></pre><p>六、微信红包<br></p><pre><code>#pragma mark - 微信红包/** *  插件功能 */static int const kCloseRedEnvPlugin = 0;static int const kOpenRedEnvPlugin = 1;static int const kCloseRedEnvPluginForMyself = 2;static int const kCloseRedEnvPluginForMyselfFromChatroom = 3;//0：关闭红包插件//1：打开红包插件//2: 不抢自己的红包//3: 不抢群里自己发的红包static int HBPliginType = 1;#define SAVESETTINGS(key, value) { \NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); \NSString *docDir = [paths objectAtIndex:0]; \if (!docDir){ return;} \NSMutableDictionary *dict = [NSMutableDictionary dictionary]; \NSString *path = [docDir stringByAppendingPathComponent:@&quot;HBPluginSettings.txt&quot;]; \[dict setObject:value forKey:key]; \[dict writeToFile:path atomically:YES]; \}//#define LOADSETTINGS(key) ({ \//NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); \//NSString *docDir = [paths objectAtIndex:0]; \//if (!docDir){ return} \//NSString *path = [docDir stringByAppendingPathComponent:@&quot;HBPluginSettings.txt&quot;]; \//NSDictionary *dict = [[NSDictionary alloc] initWithContentsOfFile:path]; \//if(!dict){ return} \//NSNumber *number = [dict objectForKey:key]; \//0//})CHDeclareClass(CMessageMgr);CHMethod(2, void, CMessageMgr, AsyncOnAddMsg, id, arg1, MsgWrap, id, arg2){    CHSuper(2, CMessageMgr, AsyncOnAddMsg, arg1, MsgWrap, arg2);    Ivar uiMessageTypeIvar = class_getInstanceVariable(objc_getClass(&quot;CMessageWrap&quot;), &quot;m_uiMessageType&quot;);    ptrdiff_t offset = ivar_getOffset(uiMessageTypeIvar);    unsigned char *stuffBytes = (unsigned char *)(__bridge void *)arg2;    NSUInteger m_uiMessageType = * ((NSUInteger *)(stuffBytes + offset));    Ivar nsFromUsrIvar = class_getInstanceVariable(objc_getClass(&quot;CMessageWrap&quot;), &quot;m_nsFromUsr&quot;);    id m_nsFromUsr = object_getIvar(arg2, nsFromUsrIvar);    Ivar nsContentIvar = class_getInstanceVariable(objc_getClass(&quot;CMessageWrap&quot;), &quot;m_nsContent&quot;);    id m_nsContent = object_getIvar(arg2, nsContentIvar);    switch(m_uiMessageType) {        case 1:        {            //普通消息            //红包插件功能            //0：关闭红包插件            //1：打开红包插件            //2: 不抢自己的红包            //3: 不抢群里自己发的红包            //微信的服务中心            Method methodMMServiceCenter = class_getClassMethod(objc_getClass(&quot;MMServiceCenter&quot;), @selector(defaultCenter));            IMP impMMSC = method_getImplementation(methodMMServiceCenter);            id MMServiceCenter = impMMSC(objc_getClass(&quot;MMServiceCenter&quot;), @selector(defaultCenter));            //通讯录管理器            id contactManager = ((id (*)(id, SEL, Class))objc_msgSend)(MMServiceCenter, @selector(getService:),objc_getClass(&quot;CContactMgr&quot;));            id selfContact = objc_msgSend(contactManager, @selector(getSelfContact));            Ivar nsUsrNameIvar = class_getInstanceVariable([selfContact class], &quot;m_nsUsrName&quot;);            id m_nsUsrName = object_getIvar(selfContact, nsUsrNameIvar);            BOOL isMesasgeFromMe = NO;            if ([m_nsFromUsr isEqualToString:m_nsUsrName]) {                //发给自己的消息                isMesasgeFromMe = YES;            }            if (isMesasgeFromMe)            {                if ([m_nsContent rangeOfString:@&quot;打开红包插件&quot;].location != NSNotFound)                {                    HBPliginType = kOpenRedEnvPlugin;                }                else if ([m_nsContent rangeOfString:@&quot;关闭红包插件&quot;].location != NSNotFound)                {                    HBPliginType = kCloseRedEnvPlugin;                }                else if ([m_nsContent rangeOfString:@&quot;关闭抢自己红包&quot;].location != NSNotFound)                {                    HBPliginType = kCloseRedEnvPluginForMyself;                }                else if ([m_nsContent rangeOfString:@&quot;关闭抢自己群红包&quot;].location != NSNotFound)                {                    HBPliginType = kCloseRedEnvPluginForMyselfFromChatroom;                }                SAVESETTINGS(@&quot;HBPliginType&quot;, [NSNumber numberWithInt:HBPliginType]);            }        }            break;        case 49: {            // 49=红包            //微信的服务中心            Method methodMMServiceCenter = class_getClassMethod(objc_getClass(&quot;MMServiceCenter&quot;), @selector(defaultCenter));            IMP impMMSC = method_getImplementation(methodMMServiceCenter);            id MMServiceCenter = impMMSC(objc_getClass(&quot;MMServiceCenter&quot;), @selector(defaultCenter));            //红包控制器            id logicMgr = ((id (*)(id, SEL, Class))objc_msgSend)(MMServiceCenter, @selector(getService:),objc_getClass(&quot;WCRedEnvelopesLogicMgr&quot;));            //通讯录管理器            id contactManager = ((id (*)(id, SEL, Class))objc_msgSend)(MMServiceCenter, @selector(getService:),objc_getClass(&quot;CContactMgr&quot;));            Method methodGetSelfContact = class_getInstanceMethod(objc_getClass(&quot;CContactMgr&quot;), @selector(getSelfContact));            IMP impGS = method_getImplementation(methodGetSelfContact);            id selfContact = impGS(contactManager, @selector(getSelfContact));            Ivar nsUsrNameIvar = class_getInstanceVariable([selfContact class], &quot;m_nsUsrName&quot;);            id m_nsUsrName = object_getIvar(selfContact, nsUsrNameIvar);            BOOL isMesasgeFromMe = NO;            BOOL isChatroom = NO;            if ([m_nsFromUsr isEqualToString:m_nsUsrName]) {                isMesasgeFromMe = YES;            }            if ([m_nsFromUsr rangeOfString:@&quot;@chatroom&quot;].location != NSNotFound)            {                isChatroom = YES;            }            if (isMesasgeFromMe &amp;&amp; kCloseRedEnvPluginForMyself == HBPliginType &amp;&amp; !isChatroom) {                //不抢自己的红包                break;            }            else if(isMesasgeFromMe &amp;&amp; kCloseRedEnvPluginForMyselfFromChatroom == HBPliginType &amp;&amp; isChatroom)            {                //不抢群里自己的红包                break;            }            if ([m_nsContent rangeOfString:@&quot;wxpay://&quot;].location != NSNotFound)            {                NSString *nativeUrl = m_nsContent;                NSRange rangeStart = [m_nsContent rangeOfString:@&quot;wxpay://c2cbizmessagehandler/hongbao&quot;];                if (rangeStart.location != NSNotFound)                {                    NSUInteger locationStart = rangeStart.location;                    nativeUrl = [nativeUrl substringFromIndex:locationStart];                }                NSRange rangeEnd = [nativeUrl rangeOfString:@&quot;]]&quot;];                if (rangeEnd.location != NSNotFound)                {                    NSUInteger locationEnd = rangeEnd.location;                    nativeUrl = [nativeUrl substringToIndex:locationEnd];                }                NSString *naUrl = [nativeUrl substringFromIndex:[@&quot;wxpay://c2cbizmessagehandler/hongbao/receivehongbao?&quot; length]];                NSArray *parameterPairs =[naUrl componentsSeparatedByString:@&quot;&amp;&quot;];                NSMutableDictionary *parameters = [NSMutableDictionary dictionaryWithCapacity:[parameterPairs count]];                for (NSString *currentPair in parameterPairs) {                    NSRange range = [currentPair rangeOfString:@&quot;=&quot;];                    if(range.location == NSNotFound)                        continue;                    NSString *key = [currentPair substringToIndex:range.location];                    NSString *value =[currentPair substringFromIndex:range.location + 1];                    [parameters setObject:value forKey:key];                }                //红包参数                NSMutableDictionary *params = [@{} mutableCopy];                [params setObject:parameters[@&quot;msgtype&quot;]?:@&quot;null&quot; forKey:@&quot;msgType&quot;];                [params setObject:parameters[@&quot;sendid&quot;]?:@&quot;null&quot; forKey:@&quot;sendId&quot;];                [params setObject:parameters[@&quot;channelid&quot;]?:@&quot;null&quot; forKey:@&quot;channelId&quot;];                id getContactDisplayName = objc_msgSend(selfContact, @selector(getContactDisplayName));                id m_nsHeadImgUrl = objc_msgSend(selfContact, @selector(m_nsHeadImgUrl));                [params setObject:getContactDisplayName forKey:@&quot;nickName&quot;];                [params setObject:m_nsHeadImgUrl forKey:@&quot;headImg&quot;];                [params setObject:[NSString stringWithFormat:@&quot;%@&quot;, nativeUrl]?:@&quot;null&quot; forKey:@&quot;nativeUrl&quot;];                [params setObject:m_nsFromUsr?:@&quot;null&quot; forKey:@&quot;sessionUserName&quot;];                if (kCloseRedEnvPlugin != HBPliginType) {                    //自动抢红包                    ((void (*)(id, SEL, NSMutableDictionary*))objc_msgSend)(logicMgr, @selector(OpenRedEnvelopesRequest:), params);                }                return;            }            break;        }        default:            break;    }}</code></pre><p>七、安装iOSOpenDev失败的解决方法    </p><pre><code>先重启Xcode，在Xcode中创建新项目中，查看菜单iOS中是否存在iOSOpenDev 一项内容     </code></pre><p>1.<a href="https://github.com/kokoabim/iOSOpenDev/wiki/Troubleshoot" target="_blank" rel="noopener">官方解决方法</a><br></p><pre><code>1.在点击 安装iOSOpenDev软件的失败弹框 任意地方，使其成为Mac菜单即可;2.Command + L 显示安装日志弹框;3.在弹框的左上角选择 &quot;显示所有日志&quot;;4.滚动到日志底部，查看失败原因;5.根据原因处理问题;</code></pre><p>2.其他解决方法</p><p>八、其他<br>1.iOS可执行文件位置：</p><pre><code>一般我们得到的iOS程序包是.ipa文件。其实就是一个压缩包，解压缩.ipa。解压缩后里面会有一个payload文件夹，文件夹里有一个.app文件，右键显示包内容，然后找到一个一般体积最大跟.app同名的文件，那个文件就是可执行文件；</code></pre><p>参考资料：<br>1.<a href="https://www.jianshu.com/p/7c0c2bcbbaf2" target="_blank" rel="noopener">非越狱微信步数和红包</a>    <br><br>2.<a href="https://www.jianshu.com/p/189afbe3b429" target="_blank" rel="noopener">非越狱iOS微信自动抢红包</a>    <br><br>3.<a href="https://www.jianshu.com/p/ad578bef4b76" target="_blank" rel="noopener">非越狱iOS微信自动抢红包2</a><br><br>4.<a href="https://www.jianshu.com/p/dd600ee4d659" target="_blank" rel="noopener">非越狱iOS修改微信步数</a>    <br><br>5.<a href="https://www.ianisme.com/ios/2319.html" target="_blank" rel="noopener">安装iOSOpenDev失败的解决方法</a><br><br>6.<a href="https://blog.csdn.net/zcrong/article/details/51619381" target="_blank" rel="noopener">在非越狱平台进行越狱开发</a><br><br>7.<a href="https://www.jianshu.com/p/6c45da26040d" target="_blank" rel="noopener">iOS可执行文件分析工具MachoOView</a><br><br>8.<a href="https://github.com/KJCracks/yololib" target="_blank" rel="noopener">yololib - 动态注入</a><br><br>9.<a href="https://www.jianshu.com/p/5d353d6db145" target="_blank" rel="noopener">insert_dylib的使用方法</a><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、工具和软件&lt;br&gt;1.&lt;a href=&quot;https://pro.25pp.com/pp_mac_ios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PP助手Mac版&lt;/a&gt;&lt;br&gt;&lt;br&gt;2.iOS微信App(越狱) 6.6.7 - Mac PP助手
      
    
    </summary>
    
      <category term="iOS" scheme="http://tao1010.github.io/categories/iOS/"/>
    
    
      <category term="逆向" scheme="http://tao1010.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序-组件-表单组件</title>
    <link href="http://tao1010.github.io/2018/06/08/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%BB%84%E4%BB%B6-%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/"/>
    <id>http://tao1010.github.io/2018/06/08/小程序/微信小程序-组件-表单组件/</id>
    <published>2018-06-08T03:30:48.000Z</published>
    <updated>2018-06-20T13:23:58.459Z</updated>
    
    <content type="html"><![CDATA[<p>一、button<br>1.属性列表    </p><pre><code>size 按钮大小 String 默认 default    有效值： default、 minitype 按钮的样式类型 String default    有效值：primary、default、warnform-type 用于&lt;form/&gt;组件，点击分别会触发&lt;form/&gt;组件的submit/reset事件；    有效值:submit、resetplain 按钮是否镂空，背景色透明 默认falsedisabled    是否禁用 falseloading  名称前是否带有loading图标 falseopen-type  微信开发能力 String    有效值：    contact     打开客服会话    share        触发用户转发    getUserInfo 获取用户信息，可以从bindgetuserinfo回调中获取到用户信息    getPhoneNumber 获取用户手机号，可以从bindgetphonenumber回调中获取到用户信息    launchApp   可以从bindgetphonenumber回调中获取到用户信息    openSetting 可以从bindgetphonenumber回调中获取到用户信息hover-class 指定按钮按下去的样式类，hover-class=‘none’时，没有点击态效果 默认button-hover...</code></pre><p>2.tips        </p><pre><code>button-hover 默认 {background-color: rgba(0,0,0,0.1);opacity:0.7}在bindgetphonenumber 等返回加密信息的回调中 调用wx.login登录，可能会刷新登录状态。此时服务器使用 code 换取的 sessionKey 不是加密时使用的 sessionKey，导致解密失败。建议开发者提前进行 login；或者在回调中先使用 checkSession 进行登录态检查，避免 login 刷新登录态</code></pre><p>3.eg:</p><pre><code>&lt;button type=&quot;warn&quot; size=&quot;mini&quot;&gt;按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; loading=&quot;true&quot;&gt;页面主操作 Loading&lt;/button&gt;&lt;button type=&quot;primary&quot; disabled=&quot;true&quot; plain=&quot;true&quot;&gt;不可点击的按钮&lt;/button&gt;...        </code></pre><p>二、checkbox - 多项选择器，内部由多个checkbox组成<br><br>1.属性<br>        </p><pre><code>checkbox-group:    bindchange &lt;checkbox-group/&gt;中选中项发生改变是触发 change 事件，detail = {value:[选中的checkbox的value的数组]}checkbox：    value &lt;checkbox/&gt;标识，选中时触发&lt;checkbox-group/&gt;的 change 事件，并携带 &lt;checkbox/&gt; 的 value    disabled 是否禁用 默认false    checked  当前是否选中，可用来设置默认选中 默认false    color        checkbox颜色 </code></pre><p>2.eg</p><pre><code>xx.wxml&lt;text&gt;多项选择&lt;/text&gt;  &lt;checkbox-group bindchange=&quot;checkboxChange&quot;&gt;    &lt;view class=&apos;checkbox&apos;&gt;      &lt;label class=&apos; checkBox&apos; wx:for=&quot;{{coutry}}&quot;&gt;      &lt;checkbox value=&quot;{{item.name}}&quot; checked=&quot;{{item.checked}}&quot;&gt;{{item.value}}&lt;/checkbox&gt;    &lt;/label&gt;    &lt;/view&gt;  &lt;/checkbox-group&gt;xx.jsPage({    data: {    coutry:[      { name: &apos;USA&apos;, value: &apos;美国&apos; },      { name: &apos;CHN&apos;, value: &apos;中国&apos;, checked: &apos;true&apos; },      { name: &apos;BRA&apos;, value: &apos;巴西&apos; },      { name: &apos;JPN&apos;, value: &apos;日本&apos; },      { name: &apos;ENG&apos;, value: &apos;英国&apos; },      { name: &apos;TUR&apos;, value: &apos;法国&apos; },    ]  },  checkboxchange: function(e){    console.log(&apos;checkbox发生change事件，携带value值为：&apos;,e.detail.value)  }})</code></pre><p>三、form        </p><pre><code>表单，将组件内的用户输入的&lt;switch/&gt; &lt;input/&gt; &lt;checkbox/&gt; &lt;slider/&gt; &lt;radio/&gt; &lt;picker/&gt; 提交。当点击 &lt;form/&gt; 表单中 formType 为 submit 的 &lt;button/&gt; 组件时，会将表单组件中的 value 值进行提交，需要在表单组件中加上 name 来作为 key</code></pre><p>四、input<br>1.属性<br></p><pre><code>type input的类型 默认‘text’    有效值: text number idcard(身份证输入键盘) digit(带小数点的数字键盘)confirm-type 设置键盘右下角按钮的文字 默认‘done’    有效值: send-发送 search-搜索 next-下一个 go-前往 done-完成    value 输入框的初始内容 password 是否是密码类型 默认falseplaceholder 输入框为空时的占位符placeholder-style 指定placeholder的样式placeholder-class 指定placeholder的样式类maxlength 最大输入长度 140 设置为-1时不限制最大长度cursor-spacing 指定光标与键盘的距离单位px focus 获取焦点 falseconfirm-hold 点击键盘右下角按钮时，是否保持键盘不收起 默认falsecursor    指定focus时的光标位置    adjust-position 键盘弹起时，是否自动上推页面 默认truebindinput 键盘输入时，触发input事件bindfocus    输入框聚焦时触发bindblur    输入框失去焦点时触发bindconfirm 点击完成按钮时触发</code></pre><p>五、label        </p><pre><code>用来改进表单组件的可用性，使用for属性找到对应的id，或者将控件放在该标签下，当点击时，就会触发对应的控件。for优先级高于内部控件，内部有多个控件的时候默认触发第一个控件。目前可以绑定的控件有：&lt;button/&gt;, &lt;checkbox/&gt;, &lt;radio/&gt;, &lt;switch/&gt;</code></pre><p>六、滚动选择器</p><pre><code>从底部弹起的滚动选择器，现支持五种选择器，通过mode来区分:    mode = selector 普通选择器 - 默认    mode = multiSelecto 多列选择器    mode = time 时间选择器    mode = date 日期选择器    mode = region 省市区选择器        </code></pre><p>1.picker - 嵌入页面的滚动选择器<br><br>2.picker-view - 嵌入页面的滚动选择器</p><pre><code>其中只可放置&lt;picker-view-column/&gt;组件，其他节点不会显示;picker-view-column:    仅可放置于&lt;picker-view /&gt;中，其孩子节点的高度会自动设置成与picker-view的选中框的高度一致滚动时在iOS自带振动反馈，可在系统设置 -&gt; 声音与触感 -&gt; 系统触感反馈中关闭</code></pre><p>七、radio - 单项选择器，内部由多个<radio>组成<br><br>八、slider - 滑动选择器<br>九、switch - 开关选择器<br>十、textarea - 多行输入框</radio></p><pre><code>bug: 微信版本 6.3.30，textarea 在列表渲染时，新增加的 textarea 在自动聚焦时的位置计算错误。tip:     textarea 的 blur 事件会晚于页面上的 tap 事件，如果需要在 button 的点击事件获取 textarea，可以使用 form 的 bindsubmit。    不建议在多行文本上对用户的输入进行修改，所以 textarea 的 bindinput 处理函数并不会将返回值反映到 textarea 上。    textarea 组件是由客户端创建的原生组件，它的层级是最高的，不能通过 z-index 控制层级。    请勿在 scroll-view、swiper、picker-view、movable-view 中使用 textarea 组件。    css 动画对 textarea 组件无效。</code></pre><p>参考资料：<br>1.<a href="https://developers.weixin.qq.com/miniprogram/dev/component/" target="_blank" rel="noopener">组件</a><br>2.<a href="https://developers.weixin.qq.com/miniprogram/dev/component/button.html" target="_blank" rel="noopener">button</a>        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、button&lt;br&gt;1.属性列表    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;size 按钮大小 String 默认 default
    有效值： default、 mini
type 按钮的样式类型 String default
    有效值：primary、defa
      
    
    </summary>
    
      <category term="小程序" scheme="http://tao1010.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://tao1010.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
